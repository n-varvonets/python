"""# Существуют два типа задач:"""
# 1) работа с процессорами CPU / GPU - различные вычисления, рендеринг видео/аудио
# 2) I/O - получение данных от пользователя/апи(РАБОТА С СЕТЬЮ)/бд/файла и возврат (запись в базу данных/ отдаем пользователю)

# СОКЕТ - это пара (домента и порта)... через который осуществляет взаимодействие между двумя субьектами(клиент и сервер).
# domain:5000

import socket
# СЕРВЕР обслуживаем работу клиента.  Всю оснвную логику прописываем здесь.
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # AF_INET - ipV4, SOCK_STREAM - tcp протокол
# если прервется работа скрипта, то порт будет занят(таймаут 3 мин в убунту)
"этот таймаут нужен для того что бы те данные, которые находятся в пути - до шли до своего адрессата"
#  для возможности повторного использование того же порта нужно переопрделить опцию SOL_SOCKET в true :
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # SO - socket_option | 1 = true
server_socket.bind(('localhost', 5000))  # bind -  принимает кортеж

# устанавливаем прослушивание сервера на предмет входящих подключений
server_socket.listen()

# отношения между клиентов и сервером это всегда длящие отношения(мы не знаем сколько времени оно займет-поэтому while)
while True:
    print('Before accept()')
    # теперь нам нужен принимать клиентский сокет
    # есть метод (accept - принимать), который принимает кортеж (клиентский сокет и его адрес)
    client_socket, addr = server_socket.accept()  # метод эксепт это блокирующая функция:
    # http://i.imgur.com/eXZVqO8.png - потому что если запустить сервер, то скрипт будет стоять на месте и ожидать \
    # подключения клиента и дальше не пойдет
    print('Connection from client', addr)

    # итак.. подключение мы приняли.. теперь должны дождаться от клиента каких-то действий - опять бесконечный цикл
    while True:  # как только клиент подключится мы перейдем в данный цикл и будем ждать от клиента действий
        print('Before recv()')
        # определю переменную запрос, кото рая будет приминмать от клиентского сокета какое-то сообщение(запрос)
        request = client_socket.recv(4096)  # буфер сообщения - 4 килабит.
        # recv - тоже блокирующая функция - сервер ничего не ответит пока клиент не введет запрос какой-то
        # recv - это какой-то обьем памяти - БУФЕР

        # напишем условие для прерывание этого цикла
        if not request:
            break
        else:
            response = 'Hello world\n'.encode()  # нужно для передачи данных цифровой вид закодировать в биты как ответ
            # собсна и отправить наше сообщение клиенту  через раочий сокет клиента
            client_socket.send(response)  # send - очищает наш буфер и передает данные клиенту и передает \
            # Управление обратно методу recv... и ресив дальше будет блокировать выполнение операции пока будет пуст

            """
            ПРОБЛЕМА: состоит в том что из этого цикла мы не выйдем, пока клиент не прервет соединение - \
            т.е. мы не сможем принят другого клиента...КОНТРОЛЬ УПРАВЛЕНИЯ находится внутри второго цикла..
            ВОПРОС: пока выполняется второй цикл - КАК принять нового клиента передав ему контроль управления\
            не закрывая первого клиента?
            РЕШЕНИЕ: нужно передавать контроль выполнения работы программы... каким-то образом её приостанавливать...\
            и потом каким-то образом снова брать контроль выполнения ПРИ НАСТУПЛЕНИЯ ОПРЕДЕЛЕННЫХ СОБЫТИЙ...
            **когда входящий буфер (recv) заполняется и когда исходящий буфер(send) - очищается**
            
            """

    print('Эта надпись появится только тогда, когда мы выйдем из верхнего цикла - закрыв клиента, но не появится\
     при попытке подключения нового, потому что второй цикл будет блокировать')
    client_socket.close()

# Любая функция - БЛОКИРУЮЩАЯ.
# функция - блокирует выполнения программы ДО ТЕХ ПОР, ПОКА НЕ ЗАКОНЧАТ ВЫПОЛНЕНИЕ СВОЕЙ РАБОТЫ \
# И НЕ ВЕРНУТ НАМ РЕЗУЛЬТАТ. Вместе с результатом - ВОЗВРАЩАЕТСЯ КОНТРОЛЬ УПРАВЛЕНИЯ СКРИПТА в то место, откуда \
# произошел вызов функции
