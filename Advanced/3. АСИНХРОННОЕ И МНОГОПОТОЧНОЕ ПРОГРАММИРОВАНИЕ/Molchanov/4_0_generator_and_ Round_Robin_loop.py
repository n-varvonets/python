"""1.Генераторы - это функция(отдает результат), а не последовательность значений в с списке с перспективы(точки зрения) если
 сравнивать его(генератор) как своего рода облегченный список"""

def gen(s):
    for i in s:
        yield i

# так как функция, то нужно с него создать обьект, который быдем передавать в функцию next

g = gen('Oleg')

print(gen)
print(g)

print(next(g))
print('мы вернули управление, а генератор остался на моменте выполнения(или пошел обрабатывать след запрос), но гланое\n'
      'это то что врнели управление, и можем выполнять что захотим. но выполняться сам генератор не будет(или будет\n'
      'в фоновом режиме/на втором плане/в другом потоке). и После того можем обратно вызвать функцию gen(), что бы \n'
      'получить результат(в нашем случае - это след буква "о")\n'
      'Т.е. поставить функцию на паузу -> вернуть управление и что-то сделать ->  а потом продолжить выполнение с того же самого момента')
print(next(g))

"""2. Yield - это не return  и вот особенность:"""
from time   import time

def gen_filename():
    while True:
        pattern = 'file = {}.jpeg'
        t = int(time() * 1000)
        yield print(pattern.format(str(t)))

        # вот ключевой момент отличающий генератор(yield) от функции(return)...
        # 1)после yield  можно можно написать код, который выполниться при след вызове next...(но не параллельно)..
        # т.е. когда получили результат генератора - мы можем обработать его как-то(изменить/отправить куда-то еще или
        # вызвать еще какую-то функцию), а потом снова вызвать генератор, что бы снова получить результат выполнения
        # 2)т.е. после вызова next во второй раз он доделывает то что недоделал в первый раз до вхождение в yield
        # 2.1)yield-ов может быть несколько в одной функции
        sum = 247 + 247

        print(sum)

g = gen_filename()
next(g)
next(g)

"""Пример принципа событийного цикла Round Robin - КАРУСЕЛЬ"""


def gen_str(s):
    for i in s:
        yield i


def gen_int(n):
    for i in range(n):
        yield i

g1 = gen_str('nick')
g2 = gen_int(8)

tasks = [g1, g2]

while tasks:  # т.е. список будет работать пока в списке будет хоть одна задача
    task = tasks.pop(0)

    try:
        i = next(task)
        print(i)
        tasks.append(task)  # и добавляем в список задач наш уже один раз отработанный(next) обьект генератора
    except StopIteration:
        pass

