"""
Принципиальная схема работы event_loop:
1.event_loop берет из очереди первую задачу task.
2.у ассоциарованной с этим таском корутиной вызывается метод step().Корутина выполняет свой код.
3.если корутина вызывает другую корутину, то она стает делегирующей корутиной и останавливает свое выполнения,
отдав контроль выполнения другой корутины
4.если эта корутина вызывает блок.функцию, то она отдает контроль выполнения event_loop(у)
5.теперь уже event_loop рет следуюущую задачу и т.д. и т.п. по кругу....
6. когда event_loop доходит обратно до первой задачи, то у ассоциарованной с этой задачей корутина продолжает
выполнение с того места на котором отдала в прошлый раз контроль
"""

# для примера создадим синхронную реализацию задачи(функция виводит числа, а другая выводит какое-то смс раз в н сек)

import asyncio


@asyncio.coroutine  # из функции создает генератор
def print_nums():
    """
    каждую секунду принтует смс отдавая при этомм контроль управления
    """
    num = 1
    while True:
        print(num)
        num += 1
        # длаьше что бы избежать бешенной скорости вывода чисел сделаем "вид работы" функцией sleep(но она не подойдет,
        # потому чвто она блокирующая и нагшлухо заблокирует поток, если другая функия захочет выполниться)
        yield from asyncio.sleep(1)  # в отличии от обычной sleep - от asyncio ет вид работы, но при этом
        # отдает управление при блоке при помощи yield from


@asyncio.coroutine
def print_time():
    """
    каждую секнду count будет увеличиваться на еденицу, отдавая контроль управления
    раз в три секунды будет возвращать(принтовать) полезное сообщение
    """
    count = 0
    while True:
        if count % 3 == 0:  # остаток отделения... берем раз в три секи принтавать
            print(f'{count} seconds passed')
        count += 1
        yield from asyncio.sleep(1)


@asyncio.coroutine
def main():
    """asyncio обеспечивает создания будущего ensure_future для корутин"""
    # обаравчиваем корутины в при помощи ensure_future наши корутина попали в чоередь  event_loop
    task1 = asyncio.ensure_future(print_nums())
    task2 = asyncio.ensure_future(print_time())

    # теперь я должен дождаться их результата(изменения состояния сокета через select()) методом gather()
    yield from asyncio.gather(task1, task2)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()  # здадим обьект ивент лупа
    loop.run_until_complete(main())  # говорим обьекту слушать генератор пока не будет прерван цикл
    loop.close()
