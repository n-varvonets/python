# главный минус threading состоит в том что потоки
# выполняются не в один момент времени, а они просто чередуются из-за GIL
"""
Перед тем как поток получает управление - он пытается заблокировать muteX:(
    - если muteX(блокировка) свободная - то он получает управление;
    - если muteX(блокировка) не свободная - то просто уведомляет что хотел бы захватить и потом просто засыпает.
Многопоточная программа последовательно переклюется между этими тредами, а в каждый момент времени может выполняться
только один поток...
Таким образом на выполнение потоков еще накладывается и задержка на:
    - блокировку; wait()
    - на освобождение muteX; release()
    - захват muteX другим потоком... set()
"""

import threading
import time


def handler(started=0, finished=0):
    result = 0
    for i in range(started, finished):
        result += i
    print('Value: ', result)


params = {'finished': 2 ** 26}

"""первый вариант выполнения скрипта в отдельном потоке"""
# предварительное создание потока, который будет выполнять функцию handler,
# с ключевыми аргументами params.
task = threading.Thread(target=handler, kwargs=params)
started_at = time.time()
print('RESULTS 1')
# запускаем поток на выполнение
task.start()
# присоединяем поток(который мы создали сами) к текущему(основному потоку выполнения) -
# то есть мы как бы синхронизируем второй поток, дожидаясь от него результата блокируя дальнейшие вычисления
task.join()  # join -заблокирует интрепритатор на данной строке  до тех пор пока тело функции handler не завершит свою
# работу, а ПОТОМ ПРИСОЕДЕНИТ РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ К ОБЩЕМУ ПОТОКУ и продолжить дальше выполняться
print('Tim e: {}'.format(time.time() - started_at))

"""второй вариант синхронного выполнения"""
started_at = time.time()
print('RESULTS 2')
handler(**params)
print('Time: {}'.format(time.time() - started_at))
