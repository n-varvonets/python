Celery - это библиотека для Python, которая позволяет выполнять асинхронные и параллельные задачи на фоне основной программы.
       - таск менеджер, брокер хранит таски
    - redis используется как msg broker(в 4ой версии редис с селари работает стабильно, перстал терять смски тасок и производительней чем rabbitMQ)
    - aws sqs если нужен hish availability(в будещем как олтернатива redis)

Умньіе люди на практике пришли к тому что таски

Проблематика. Требовалось решить следующие задачи:

    - Запускать отдельные фоновые задачи  по триггеру.
        - любые типы уведомлений: email, push, desktop
        - переодическое обновление данньіх


    - Делать пакетные обработки задач, то же смое что отдельньіе задачи,  НО запускать сразу много задач.

    - Встроить процесс Extract Transform Load.
        - Extract (загруаем данньіе из внешних источников и сохраняем сьірьмм)
        - Transform (обрабатьіваем под нашу логику)
        - TLoad загружаем в бд

    - Реализовать асинхронный API.

    - Выполнять периодические задачи. Ни один проект не обходится без периодических задач, для некоторых
      можно обойтись Cron, но есть и более удобные инструменты.

    - Построить триггерную архитектуру: на срабатывание триггера запускать задачу, которая обновит данные.
      Делается это, чтобы компенсировать недостаток runtime-мощностей предрасчетом данных в фоновом режиме.


Хорда (chord) в контексте программирования на Python и использования библиотеки Celery для асинхронных задач относится
к группе задач, которые должны быть выполнены параллельно, а затем результаты собраны и обработаны ещё одной задачей.
минус: хорда что бьі запустить после себя callback требует наличие result backend(часто ипользуют свои).
Хорда: - мьі ему передем набор задач + одну задачу callback(которая віьполнится по заверщанию тасок, а вот
что бьі понять что задачи завершились, celery использует result backend внутри себя)

Оформление кода
    1) держать минимум логики в задаче: тут правильный подход с точки зрения модульности приложения
    Мы используем задачки только как «запускаторы» кода.
    То есть задача не несет в себе логику, а триггерит запуск кода в Background.
    @celery_app.task(queue='...')
    def run_regular_update(provider_account_id, *args, **kwargs):
        """..."""
        flow = flows.RegularSyncProviderAccountFlow(provider_account_id)
        return flow.run(*args, **kwargs)
    Весь код мы выносим во внешние классы, которые используют еще какие-то классы.
    Все задачи по сути состоят из двух строчек.
    2) Простые объекты в параметрах (как правило только id)
    Если так не делать, то мы видели очень большие спайки потребляемой памяти у Redis.
    Сообщение начинает занимать больше памяти, сеть сильно загружается, количество обработанных задач (производительность) падает
    3) Идемпотентные задачи - При повторном выполнении участка кода никаких побочных-эффектов произойти не должно, результат должен быть тот же.
    4) Обратная совместимость
    Неважно, какой тип деплоя вы используете (blue+green или rolling update), всегда возникнет ситуация, когда старый код сервиса создает сообщения для нового кода воркера, и наоборот.
    Мы ловили ошибки и теряли задачи, пока не научились поддерживать обратную совместимость между релизами.
    Поэтому во всех задачах мы сейчас делаем «резиновую» сигнатуру (**kwargs).
    5) Таймауты
    Не ставить таймаут на задачу — это зло. Это значит, что вы не понимаете, что происходит в задаче, как должна работать бизнес-логика.
    Обязательно должны быть проставлены: soft_limit_timeout и expires.
    6) Retry policy
    Для тех задач, которые можно повторить, или которые могут выполниться с ошибками, мы используем Retry policy.
    Но используем аккуратно, чтобы не завалить внешние сервисы.
    7) Утечки памяти
    К сожалению, утечки памяти возникают очень легко, а найти и исправить их сложно.
    8) В целом работа с памятью у Python очень спорная. Вы потратите много времени и нервов, чтобы понять, почему происходит утечка, а потом выяснится, что она даже не в вашем коде.
    Поэтому всегда, начиная проект, проставляйте лимит памяти на воркер: worker_max_memory_per_child.
    Это гарантирует, что однажды не придет OOM Killer, не убьет все воркеры, и вы не потеряете все задачи. Celery будет сам перезапускать воркеры, когда нужно.
    9) Приоритет выполнения задач




add info:

Брокер - это посредник между покупателем и продавцом.
В основном, они помогают людям купить или продать вещи, как акции, на финансовом рынке.
Другими словами, брокер помогает людям, которые хотят инвестировать свои деньги.