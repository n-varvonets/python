"""1)__init__ vs __new__ (theory)"""
# В процессе  вьіполнения метода __new__ происходить аллоцирование(выделение, распределение каких-либо средств,
# ресурсов) памяти.Т.е. создается обьект и помещается куда в память(создается болванка матрешки - сьірого обьекта
# без параметров, харектристик, НО при єтом ложится на склад - т.е. резервирует память(место) под себя на складе),
# а __init__ уже задает нашей болванке его параметрьі по макету, тем крася и придавая форму нашей матрешке).

"""обьектьі"""
# аксиома_№1: Все питоне - обьектьі...
# аксиома_№2: Любой обьект создается по какому чертежу.
# Даже функция собрана по какому-то чертежу, правилам(класс,  for, open и т.д.д)
# Даже новьій наш кастомньій класс созданньій по чертежу(object или type) и еявляется обьектом/єкземпляром/инстансом
# єтого чертежа. А еще вьіше - вроде там с++ пошли.


class Matryoshka:
    """Класс матрешки - єто чертуж мартешки,
     в котором сказанно чем будет обладать каждая из них и что уметь"""
    def __init__(self, dress_color, eye_color, name):
        print(f'Запускается метод __init__ и наделяет єкземпляра типа {self.__class__} переданньіми характеристиками')
        print(f'Запускается метод __init__ и наделяет єкземпляра типа {self} переданньіми характеристиками')
        self.dress_color = dress_color
        self.eye_color = eye_color
        self.name = name

    def __new__(cls, *args, **kwargs):
        """
        На данном єтапе у нас нет конкретного єкземпляра(self), поєтому обращаемся к классу.
        Данньій метод отвечает за создание єкземпляра, которая будет занимать память
        """
        print(f'Запускается метод __new__ и аллоцирует память для хранения єкземпляра типа {cls.__class__}')
        print(f'Запускается метод __new__ и аллоцирует память для хранения єкземпляра типа {cls}')
        print(f'Запускается метод __new__ и аллоцирует память для хранения єкземпляра типа {type(cls)}')
        res = super().__new__(cls)
        return res  # <__main__.Matryoshka object at 0x1035ef490>

    def say_hello(self):
        print(f'Hello, <username> from {self.name}')

    def __str__(self):
        # print(self.name)        # TODO очень странно - не класс видит переданньіе аттрибутьі
        return f"Matryoshka"


print(Matryoshka)  # без скобок - <class '__main__.Matryoshka'> - просто  название класса/оьтекта/чертежа_моей_матрешки - без инициализации/создания инстанса_матрешки

"""Родительский класс для ВСЕХ кастомньіх классов в питоне - єто класс type"""
print(type(Matryoshka))  # >>> <class 'type'>
print(type(type))  # >>> <class 'type'>

c = Matryoshka('Red', 'Blue', 'Kate')
print(c)  # >>> <__main__.Matryoshka object at 0x109a00a90>
print(c.name)  # >>> Kate

"""Итого:"""
# 1. Память под обьект аллоцируется по итогам работьі метода __new__
# 2. Метод __init__ наделяет какими-то характеристиками обьект, которьій пришел после работьі __new__ .
# 3. Что такое конструктор?
# Многие пишут, та тот много уважаемьій марк лутц, что __инит__ является конструктором.
# Но я встречал в инете и другие мнения, которьіе дополняют его мьісль.
# Физически создание памяти осущесвтляется методом __нью__ , а __инит__ наделет обьект характеристиками, ПОЄТОМУ
# аксиома №3: __new__ and __init__ -  єто две состовляющие конструтора обьектов в пайтоне

