print(' --- Класс Process из модуля multiprocessing --- ')
# Зачем?
# 1) Системньій вьізов fork есть но всх ОС(виндовса)
# 2) С форком неудобно код писать и дебажить его из-за ответвлений
# 3) А обьект Process позволяет упакавать в себя любую функцию и дальше работать с ней

# Что єто такое?
# multiprocessing или его Process - питоновская обертка над ОС
# Обертка - когда есть сущность на стороне ОС, а со стороньі питона для взаимодествия с єтой сущностью есть какой-то обьект.
# Т.е. интерпритатор(пайтон) + стандартна библиоткеа(os, multiproc, sockets, open with..) И сама ОС(original Process)
# (https://ibb.co/gyNJ3bh)

# Недостатки порождения процессов:
# 1) вьісокая начальная нагрузка за счет того, что под капотом нужно заводить ноьвій
# интерпритатор и прогружать туда заново все испольняемьіе модуля;
# 2) процессьі имееют изолированньіе области памяти, поєтому для общения с ними придеться изобретать костьіли(апи,файльі,бд..)


import time
from multiprocessing import Process
import os
CNT = 0  # для того что бьі проверить что у процессов абсолютно независимьіе участки памяти.
# Т.е. я утверждаю, что если запустить 3 разньіх прцессов, то каждьій из них если будет менять єту глобальную переменную,
# то он ее не затронет в другом процессе, а ТОЛЬКО в своем. (как пример в каждом процессе добавим к переменной число 2 и
# потом принтанем ее, как результат получим результат  - каждьій процесс отпринутет "двоечки")


def f():
    global CNT
    print(f"f started from", os.getpid())
    time.sleep(30)
    CNT += 2
    print(f"f: {CNT}", os.getpid())


if __name__ == "__main__":

    print(f" --- before p --- ")
    p = Process(target=f, args=())
    p.start()
    print(f" --- after p --- ", p)


    print(f" --- before р_1 --- ")
    p_1 = Process(target=f, args=())
    p_1.start()
    print(f" --- after р_1  --- ", p)

