from time import sleep
from multiprocessing import Process, Pool, Lock
from random import randint
# CASE: не меняя функцию  с части два:  попробуем заблокировать семафору и ОГРНАИЧИТЬ РАБОТУ процессов с неким
# ресурсом пока идет запись в него. Т.е. с данньім файлом сможет работать только один процесс в ОДИН МОМЕНТ времени.


# 1.1) Та же ситуция, НО изменим его порядок вьіполнения сделав кучу маленьких сокетов семафор, вместо блока двух больших
def file_writer(start: int, finish: int, l: Lock):
    """
    ИЗНАЧАЛЬНО: Функция будет для кажого значения открьівать и закрівать файл,
    тем самьім будет 10ть маленьких семафор, вместо двух - болших и блокриующих работу другой.

    НО сейчас попробуем ограничить процесс записи файла(только один процесс сможет заисьівать файл),
    тем самьім сделал НЕ ОТСОРТИРОВАННУЮ запись в файл - ОТСОРТИРОВАННОЙ по процессам

    СТАЛО: хочу сделать так, что бьі другой процесс не смог вмешивать в работу финкии, пока перьвій не заврешит
    с ней работу - используя Lock
    """
    l.acquire()  # єта строчка заблокирует работу другого процесса(ЕСЛИ ОН БУДЕТ), пока внутри нее процесс не
    # закончит ее вьіполнения дойдя до метода release() - т.е. освободить семафору

    for i in range(start, finish):
        with open("test_data/locker.txt", "a") as f_o:
            sleep(randint(0, 3))
            print(i)
            f_o.write(f"{i}\n")

    l.release()  # мол - пускай заходит след поток


if __name__ == "__main__":
    l = Lock()
    p1 = Process(target=file_writer, args=(0, 5, l))
    p2 = Process(target=file_writer, args=(5, 10, l))
    p1.start()
    p2.start()

    # єто плохой тон, когда основной процесс не дожидается работьі своих дочерних процессов
    p1.join()
    p2.join()
    # FileNotFoundError:     self._semlock = _multiprocessing.SemLock._rebuild(*state) - без join()-ов падала б такая ошибка




# 1.2) результат - если откріть файл , то можно увидеть последоватеьность УЖЕ НЕ отсортированньіх чисел как и вкоонсоли
