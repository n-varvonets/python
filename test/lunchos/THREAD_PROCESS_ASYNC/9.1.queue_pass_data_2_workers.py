from multiprocessing import Queue, Process
from queue import Empty
from time import sleep


def worker_1(a: int, q: Queue=None):
    """
    хочу отдавать промежуточньій итог при каждой итерации,
    что бьі главньій процесс не ожидал, пока дочерних упакует все данньіе и отдаст. Как?
    при каждом 'тике' (новой итерации) - будем отдавать данньіе - главному процессу,
    а в основном процессе мьі сможем получать их между start() and join() by method .get()
    """
    cnt = 0
    while cnt < 3:
        sleep(1)  # какое-то долгое вьісисление
        q.put(cnt)

        cnt += 1

        q.put(cnt) # в єтой строчке одаем из нашего дочернего потока - данньіе в главньій поток 

    print('worker_1 finished')


if __name__ == "__main__":
    """
    создадим обьект типа Очередь и передадим его в нашу функцию воркер.
    запускаем дочерний процесс и ловим дату полученную из дочернено и вьіводим ее на екран
    """
    q = Queue()
    p = Process(target=worker_1, args=(2, q))
    p.start()

    print(q.get())  # 0
    print(q.get())  # 1

    # ВАЖНО!!! может повиснуть, потому что ожидает что-то
    # должен прилетитеть аргумент( если закоментить строчку p.send(some_data), то пивиснет код)

    p.join()