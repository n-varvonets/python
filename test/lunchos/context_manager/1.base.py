# 1.1) Задача, как мне взаимодействовать с файлом?
f_o = open('data/test.txt', 'w')  # лишь фнкция которая вернет нам обьект для работьі с файлом
s = 'test string'
# 1.2) Ошибка многих:  они думаю что когда мьі вьізвали функцию open() и передали  туда путь к файлу и режим
# чтения/записи, то в єтот момент мьі работает с файлом.
# 1.3) На самом деле файл находится на жестком диске, а работа ведется с некой обвязкой-прослойкой питона.
# Питон на прямую с файлом не работает, она работает с обьектом, которьій может взаимодействовать на файльі жесткого
# диска черези интерфейсьінаписанньіх на CPython. И при вьізове функции open() нам возращается обьект TextIOWrapper,
# которьій можно импотнуть с io библиотеки и псмотреть как он устроен под капотом.
print(f_o)   # >>> <_io.TextIOWrapper name='data/test.txt' mode='w' encoding='UTF-8'>
from io import TextIOWrapper
# 1.4) Благодаря єтой обвязки_прослойки_обьекта_питончего мьі открьіваем с файлом коннектор на чтение или запись. И по
# правилам хороше го тона нужно кго закрьвать.
# 1.6) можно явно вьізвать метод close(). (Важно! нее у файла, а у файлового обьекта). НО.. есть проблема
raise ZeroDivisionError  # иммитация ошибки
f_o.close()

# 2.1) Проблема взаимодействия с текстовьім файлом и зачем контекстньій менеджер нужен: когда паралелльно открьіваем
# много файлов и в одном  процессе образуется ошибка до его закртьія, то интерпиритор не дойдет до
# метода close() и станет, еще + а остальніе будут вьіполняться и что с ними?
# 2.2.1) Решение №1. Через конструкцию try except finally можно вручную закрьівать.
try:
    f_o = open('data/test.txt', 'w')
except Exception as err:
    print(err)
finally:
    f_o.close()
# 2.2.1) Чем єто плохо? Что в try может разрастаться наша логика(вьізов функций, еще try/exept и т.д.) и в єтом
# можно путаться  при разростании проекта.
# 2.2.1) Решение №2. Разработчики договорились, что давайте для каждого обьекта функции open() будет реализовано два
# каких-то внтренних метода:
#       - первьій(__enter__): будем вьізьівать при начале работьі с файлом
#       - второй(__exit__): мьі будем вьізьівать при (1)ошибки или (2) обьічном завершении работьі с наши обьектом файла

# 3.1) Контекстньій менеджер - єто штука, которая позваоляет автоматически вьізвать __enter__ и __exit__ методьі
# 3.2) Контекстньій менеджер - єто только with:
f_o_1 = open('data/test.txt', 'w')  # создаим обьект обертки файла, которьій нам вернут обьект с __enter__ и __exit__ методами
with f_o_1:  # здесь и вступает в силу котекстньій менеджер
    print('context')



