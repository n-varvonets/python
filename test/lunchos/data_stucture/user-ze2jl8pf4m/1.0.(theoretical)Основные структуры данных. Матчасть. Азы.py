# Ссылка на ютуб плей-лист: https://www.youtube.com/watch?v=bUS7spptofo&t=143s&ab_channel=%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%B8%D0%B8%D0%B6%D0%B5%D1%81%D0%BD%D0%B8%D0%BC
# Ссылка на статью с хабра: https://habr.com/ru/post/422259/

"""Что такое структура данных?"""
# Структура данных — это контейнер, который хранит данные в определенном макете.
# Этот «макет» позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других.
"""Какие бывают?"""
#       - Линейные: элементы образуют последовательность или линейный список, обход узлов линеен
#               - Массивы.
#               - Связанный список
#               - стеки
#               - очереди
#       - Нелинейные: если обход узлов нелинейный, а данные не последовательны:
#               - граф
#               - деревья
"""
Основные структуры данных:"""
# - 1)Коллекция(или массив) - (1)набор єлементов (2)произвольного типа. Єто самая простая и широко используемая структура данных.
#   Другие структуры данных, такие как стеки и очереди, являются производными от массивов.
#   Бьівают:
#       1.1)Упордочньіе  коллекции -єлемент МОЖНО взять по индексу(т.е. - ordered) + (дело - ссіьлочное и
#       не аллоцирует память). Упорядочное, потому что єелемент можно взять по взять по индексу:
#       t = (1, 2, 3, 4, 5)  # (1)NOT mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes:
#       l = [1, 2, 3, 4, 5]  LinkedList (list : (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes -
#       print(l[0], t[0])  # 1 1.
#           1.1.1)Они бывают:
#               1.1.1.1) НЕизменемьіми:
#                   a) tuple_кортеж — упорядоченный набор єлементов фиксированной длины.Т.е. каждому элементу данных
#                   присваивается  положительное числовое значение (индекс),который соответствует позиции элемента в массиве.
#                   Большинство языков определяют начальный индекс массива как 0.
#
#                   b) НЕизменемьій - что бьі вставаить туда єлемент в єтотт масиив, то нужно будет
#                      (1)создать новьій,
#                      (2)скопировать в него все єелементьі,
#                      (3)учитьівая новьій,, т.е. со сдвигом n єлементов
#                      (4)удалить старьій
#                       - ГЕМОРНО
#
#               1.1.1.2.) изменемьіми:
#                       list=Связанные списки (изменяемьій) - єто апнутьій массив из-за ссьілок
#                       где каждый элемент является отдельным объектом и состоит из двух элементов – данных
#                       и ссылки на следующий узел.
#                   b) Бывают:
#                       - Однонаправленный:(1->2->3->4->NULL) - каждый узел хранит адрес или ссылку на следующий узел в списке
#                       ипоследний узел имеет следующий адрес или ссылку как NULL.
#                       - Двунаправленный: (NULL<-1<->2<->3->NULL) - две ссылки, связанные с каждым узлом, одним из опорных
#                       пунктов на следующий узел и один к предыдущему узлу.
#           1..1.2.)И деляться на :
#               - Одномерные
#               - Многомерные, массивы внутри массивов.
#                   l_2 = ([1], {1: "1", 3:[22,"222"]})
#                   t_2 = ([1], {1: "1", 3:[22,"222"]})
#                   print(l_2[1][3][1], l_2[1][3][1])  # Важно: третий єлемент возет по индексу 1, а не 22, как в первой размерности
#                   print(l_2[1][3][22], l_2[1][3][22])  # если попроовать взять 22, то упадет ошибка
#       1.2.)НЕупордочньіе  коллекции - єлемент НЕЛЬЗЯ взять по индексу, максимум в словаре - по ключу используя хеш таблицу.
#       s = {0, 1, 2, 3, 4, 5}  # set_множество(неупорядочная коллеция уникальньіх елементов) (1)mutable, (2)NOT ordered, (3)NOT indexing, (4)ability to have duplicates - NO
#       d = {"0": '-', "1": 'a', "2": 'b', "3": 'c'}  # dict/словарь: (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
#       print(s[0], d[0])  # будет ошибка
#           Хэш таблицы: в пайтоне ИЗМЕНЯЕМЬІЕ, НО єлементьі - уникальньі:
#               - set() - значения НЕ МОГУТ бьіть одинковьіх значений.
#                   s = {0, 1, 2, 3, "4", ["Lst:str"]}  # упадет ошибка, потому что значение должно
#                   бьіть определнно и униквльньім и зафиксирвоанно как хеш - TypeError: unhashable type: 'list'
#               - dict() - обьект в виде "ключ->значение",
#                     где  ключ должен бьіть уникальім для хеш-таблицьі,а значение может бьіть изеняемьім:
#                         print(d[4][12312312])  # НО упадет ощибка: если больше число, ТО ОНО НЕ зарезервированно в памяти пайтоне как ИНТ значению,
#                         то нужно хешировать его - ЄТО ОЗНАЧАЕТ ЧТО НЕЛЬЗЯ ВЗЯТЬ ЕГО ПО ИНДЕКСУ (а только по ключу)
#                     Хэширование — это процесс, используемый для:
#                         - уникальной идентификации объектов
#                         - и хранения каждого объекта в заранее рассчитанном уникальном индексе (ключе).
#                     Эффективность хеширования зависит от
#                          - Функции хеширования
#                          - Размера хэш-таблицы
#                          - Метода борьбы с коллизиями
#   3) Стеки:LIFO (last in — first out). -  абстрактный тип данных, представляющий собой список элементов
#   которая где-то посередине, вам нужно будет удалить все книги, размещенные на ней.
#   Основные операции:
#           - Push-вставляет элемент сверху
#           - Pop-возвращает верхний элемент после удаления из стека
#           - isEmpty-возвращает true, если стек пуст
#           - Top-возвращает верхний элемент без удаления из стека
#   4) Очереди: Подобно стекам -FIFO (First in First Out) вместо LIFO.
#   Примером очереди: очередь людей. Последний занял последним и будешь, а первый первым ее и покинет.
#   Основные операции:
#           - Enqueue—) — вставляет элемент в конец очереди
#           - Dequeue () — удаляет элемент из начала очереди
#           - isEmpty () — возвращает значение true, если очередь пуста
#           - Top () — возвращает первый элемент очереди
#   5) Графы:это набор узлов (вершин), которые соединены друг с другом в виде сети ребрами (дугами).
#   Бывают:
#           - Ориентированный, ребра являются направленными, т.е. существует только одно доступное направление между двумя связными вершинами.
#           - Неориентированные, к каждому из ребер можно осуществлять переход в обоих направлениях.
#   Общие алгоритмы обхода графа:
#           - Поиск в ширину – обход по уровням
#           - Поиск в глубину – обход по вершинам
#   6) Деревья: Деревья по сути связанные графы без циклов.
#   Три способа обхода дерева:
#           - В прямом порядке (сверху вниз) — префиксная форма.
#           - В симметричном порядке (слева направо) — инфиксная форма.
#           - В обратном порядке (снизу вверх) — постфиксная форма.









