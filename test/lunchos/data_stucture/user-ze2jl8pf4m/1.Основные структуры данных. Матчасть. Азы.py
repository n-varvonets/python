# Ссылка на ютуб плей-лист: https://www.youtube.com/watch?v=bUS7spptofo&t=143s&ab_channel=%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%B8%D0%B8%D0%B6%D0%B5%D1%81%D0%BD%D0%B8%D0%BC
# Ссылка на статью с хабра: https://habr.com/ru/post/422259/

"""Что такое структура данных?"""
# Структура данных — это контейнер, который хранит данные в определенном макете.
# Этот «макет» позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других.
"""Какие бывают?"""
#       - Линейные: элементы образуют последовательность или линейный список, обход узлов линеен
#               - Массивы.
#               - Связанный список
#               - стеки
#               - очереди
#       - Нелинейные: если обход узлов нелинейный, а данные не последовательны:
#               - граф
#               - деревья
"""
Основные структуры данных(
    Массивы=,
    Связанные списки=tuple(Не изменяемьій)str(Не изменяемьій),list(изменяемьій)
    Стеки=, 
    Очереди=, 
    Деревья=, 
    Хэш таблицы=set(множества - изменяемьій),dict(словарь - изменяемьій)
)"""
#   1) Массивы:Каждому элементу данных присваивается положительное числовое значение (индекс),
#   который соответствует позиции элемента в массиве. Большинство языков определяют начальный индекс массива как 0.
#   Єто самая простая и широко используемая структура данных. Другие структуры данных, такие как стеки и очереди,
#   являются производными от массивов.
#   Бывают:
#           - Одномерные
#           - Многомерные, массивы внутри массивов.
#   Основные операции:
#           - Insert-вставляет элемент по заданному индексу
#           - Get-возвращает элемент по заданному индексу
#           - Delete-удаление элемента по заданному индексу
#           - Size-получить общее количество элементов в массиве

#   2) Связанные списки: массив где каждый элемент является отдельным объектом и состоит из двух элементов – данных
#   и ссылки на следующий узел.
#   Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка
#   может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка
#   всегда явно задаётся его внутренними связями.
#   Бывают:
#           - Однонаправленный:(1->2->3->4->NULL) - каждый узел хранит адрес или ссылку на следующий узел в списке
#           ипоследний узел имеет следующий адрес или ссылку как NULL.
#           - Двунаправленный: (NULL<-1<->2<->3->NULL) - две ссылки, связанные с каждым узлом, одним из опорных
#           пунктов на следующий узел и один к предыдущему узлу.
#  Основные операции:
#           - InsertAtEnd — Вставка заданного элемента в конец списка
#           - InsertAtHead — Вставка элемента в начало списка
#           - Delete — удаляет заданный элемент из списка
#           - DeleteAtHead — удаляет первый элемент списка
#           - Search — возвращает заданный элемент из списка
#           - isEmpty — возвращает True, если связанный список пуст

#   3) Стеки:LIFO (last in — first out). -  абстрактный тип данных, представляющий собой список элементов
#   которая где-то посередине, вам нужно будет удалить все книги, размещенные на ней.
#   Основные операции:
#           - Push-вставляет элемент сверху
#           - Pop-возвращает верхний элемент после удаления из стека
#           - isEmpty-возвращает true, если стек пуст
#           - Top-возвращает верхний элемент без удаления из стека

#   4) Очереди: Подобно стекам -FIFO (First in First Out) вместо LIFO.
#   Примером очереди: очередь людей. Последний занял последним и будешь, а первый первым ее и покинет.
#   Основные операции:
#           - Enqueue—) — вставляет элемент в конец очереди
#           - Dequeue () — удаляет элемент из начала очереди
#           - isEmpty () — возвращает значение true, если очередь пуста
#           - Top () — возвращает первый элемент очереди
#   5) Графы:это набор узлов (вершин), которые соединены друг с другом в виде сети ребрами (дугами).
#   Бывают:
#           - Ориентированный, ребра являются направленными, т.е. существует только одно доступное направление между двумя связными вершинами.
#           - Неориентированные, к каждому из ребер можно осуществлять переход в обоих направлениях.
#   Общие алгоритмы обхода графа:
#           - Поиск в ширину – обход по уровням
#           - Поиск в глубину – обход по вершинам

#   6) Деревья: Деревья по сути связанные графы без циклов.
#   Три способа обхода дерева:
#           - В прямом порядке (сверху вниз) — префиксная форма.
#           - В симметричном порядке (слева направо) — инфиксная форма.
#           - В обратном порядке (снизу вверх) — постфиксная форма.
#   8) Хэш таблицы:
#   Хэширование — это процесс, используемый для:
#           - уникальной идентификации объектов
#           - и хранения каждого объекта в заранее рассчитанном уникальном индексе (ключе).
#  Объект хранится в виде пары «ключ-значение», а коллекция таких элементов называется «словарем».
#  Каждый объект можно найти с помощью этого ключа.
#  По сути это массив, в котором ключ представлен в виде хеш-функции.
#  Эффективность хеширования зависит от
#           - Функции хеширования
#           - Размера хэш-таблицы
#           - Метода борьбы с коллизиями








