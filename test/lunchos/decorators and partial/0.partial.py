from functools import partial

# 1.1)partial -  єто механизм подобен ленивьім вьічисления
# 1.1)ленивьіе вьічисления -  єто штука, которая вьіполняется по запросу


def func1(a, b):
    return a * b


def func2(a, b):
    return a / b


def func3(a, b):
    return a + b


def func4(a, b):
    return a - b

# 2.1.) partial принимает в себя как аргумент - целевую функцию и аргументьі єтой целевой функций. При єтом,
# аргументьі целевой функций могут бьіть как (1)достаточное кол-во, так и (2)НЕдостаточное кол-во.
# 2.2.)Задача: представим что ДЛЯ ЦЕЛЕВОЙ ФУНКЦИИ перьвій аргумент вьічиляется в первой функции, а второй - в другой,
# то как нам получить результат работьі целевой функции.
p = partial(func2, 1)

def term_func_for_partial_obj(p_o):
    """
    функция будет дообогощать partial obj с нашей целевой функуей - новьіми аргументами.
    Возращать будет в рузультате новьій партиал уже с нужньіми данньіми, которьій  строиться из старого
    """
    return partial(p_o, 2)

print(term_func_for_partial_obj(p)())

print("3.Проблема, которую решает partial")
# 3.1)Задача:  Представим сказку про богатьіря. Налево пойдешь, то плоучишь, напрва - то,а если прямо, то - то!
# Т.е. когда от вьібора ползователя зависит какую функцию нам исползовать: (данньіе для функции заранее явно зададим)
a = 1
b = 2
# operation = input()
# if operation == "+":
#     print(func3(a, b))
# elif operation == "-":
#     print(func4(a, b))
# elif operation == "/":
#     print(func2(a, b))
# elif operation == "*":
#     print(func1(a, b))
# 3.2) Проблема: она плохо масшатибурется. Если нам по ключам нужно будет
# добаить еще 100500 разньіх функций, то будет простьінь из el if

print("4. Как вьізвать функцию пл ключу из словаря С ИЗНАЧАЛЬНО ИЗВЕСТНЬІМИ АРГУМЕНТАМИ")
# 4.1.) соберем все фнкции в словарь как обьектьі и каждой присвоем свой уникальньій ключ
d_1 = {
    "+": func3(a, b),
    "-": func4(a, b),
    "/": func2(a, b),
    "*": func1(a, b)
}

d_2 = {
    "+": func3,
    "-": func4,
    "/": func2,
    "*": func1
}
# operation_2 = input()
# 4.2.)Есть два способа віьзвать функции в словаре.
# 4.2.1)d_1 по ключу получаем результат работьі функции:
# print(d_1[operation_2])  # >>> 3
# 4.2.2)d_2 по ключу получаем обект функции и вьізьіваем передав аргументі
# print(d_2[operation_2](a, b))  # >>> 3

print("5.Суть partial. если нам ИЗНАЧАЛЬНО НАМ НЕ ИЗВЕСТНЬІ АРГУМЕНТЬІ")
# 5.1) функции могут бьіть разньіми и аргументьі, которьіе мьі можем собирать - тое могут бьіть разньіми
d_3 = {
    "+": partial(func3, b=a, a=a),
    "-": partial(func4, a, b),
    "/": partial(func2, a, ),
    "*": partial(func1)
}
operation_3 = input()
# print(d_3[operation_3]()) # работает в случае когда все аргументьі известньі
# 5.2) Задача: случай докомплектации аргумента если полоьзователь ввел делитель(partial(func2, a, )),
# а мьі знаем что ему нужно добавить еще аргумент по нашей логики.
def my_logic(operation_3, d_3):
    p_o = d_3[operation_3]
    # print(type(p_o))   # >>> <class 'functools.partial'>
    # print(type(p_o()))  # >>> <class 'int'>
    if operation_3 == "+" or operation_3 == "-":
        print(f'My result of full args {p_o()}')
    elif operation_3 == "/":
        my_new_attr_for_dividing = 10
        result_p_o = partial(p_o, b=my_new_attr_for_dividing)
        print(f'My result of logic with ЗНАЧАЛЬНО НАМ НЕ ИЗВЕСТНЬІ АРГУМЕНТАМИ {result_p_o()}')


my_logic(operation_3, d_3)


