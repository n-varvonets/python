"""Кастомньій итератор.Зачем?"""
# Мьі написали свой кастомньій класс(СВОЮ СТРУКТУРУ ДАННЬІХ) и нам возникает потребность ее перебирать.
# Необходимость написания кастомного итератора возникает тогда, когда мы хотим тонко управлять процессом перебора.
# Например, иметь возможность при каком-то событии начать итерацию с самого начала или установить значение указателя
# перебора на определённый элемент.То есть не перебирать всё подряд, как в цикле for, а управлять вручную нашим
# процессом через непосредственное взаимодействие с итератором.
"""Вопрос: Как мне перебирать собственньій обьект?"""
#   - перебираемьій обьект: мешок картошки (ТУТ ТОЛЬКО ДАННЬІЕ, кторьіе НЕ ЗНАЮТ кто и как из будет перебирать);
#   - перебиратор или же итератор(его частньій случай - генератор): человек, которьій будет перебирать (ТУТ ТОЛЬКО
# ПРАВИЛА ПЕРЕБИБОРА, которьіе НЕ ЗНАЮТ что ему придется перебирать). т.е. некий объект, который в себе реализует
# интерфейс(т.е. в себе описывает правило) перебора чего-либо.

print(f'"""Задача №1"""')
# Условие: у нас есть тумбочка и в этой тумбочке лежат несколько предметов: ножницы, карандаш, яблоко и книга
# Задание: описать с помощью кода тумбочку, которая могла бы принимать на хранение некие объекты и выдавать
# содержимое по требованию.

# tumb = ["ножницы", "карандаш", "яблоко", "книга"]
# # получаем итератор для итерируемого объекта
# it = iter(tumb)
# try:
#     while True:
#         next_val = next(it)
#         print("Очередное значение:", next_val)
# except StopIteration:
#     # явно напечатаем сообщение об окончании итерации,
#     # хотя цикл for этого не делает и ошибка просто подавляется
#     print("Итерация закончена")
# print("Программа завершена")

print(f'"""Задача №2"""')
# Пускай у нашей тумбочки предметы хранятся в составе списковых полей, каждое из которых будет соответствовать тому
# или иному ящику. У тумбочки будут методы добавления и удаления элементов в ящики.

class Tumbochka:
    """Волшебная тумбочка с тремя ящиками для чего угодно"""

    def __init__(self):
        self.boxes = {
            1: [],
            2: [],
            3: []
        }

    def add_to_box(self, obj, box_num):
        if box_num not in {1, 2, 3}:
            print("Вы ввели неправильный номер ящика!")
        else:
            self.boxes[box_num].append(obj)

    def remove_from_box(self, box_num):
        if box_num not in {1, 2, 3}:
            print("Вы ввели неправильный номер ящика!")
        else:
            return self.boxes[box_num].pop()

    def __str__(self):
        boxes_items = self.boxes[1] + self.boxes[2] + self.boxes[3]
        return ", ".join(boxes_items)

# нагрузим тумбочку предметами и выведем информацию на экран
tumb = Tumbochka()
tumb.add_to_box("ножницы", 1)
tumb.add_to_box("карандаш", 2)
tumb.add_to_box("яблоко", 3)
tumb.add_to_box("книга", 1)
print(tumb)

print(f'"""Вьісвечиваем проблему вопроса:  как нам сделать так, чтобы нашу тумбочку можно было итерировать?"""')
# Можно, конечно, взять и сделать что-то вроде нового списка, который будет хранить в себе сумму элементов трех
# ящиков: tumb.boxes[1] + tumb.boxes[2] + tumb.boxes[3] и итерировать его, но это не очень хороший подход.
"""Почему?"""
# 1) Давайте представим себе, что у нас есть список с несколькими итерируемыми объектами: списком, множеством и строкой.
my_shiny_list_raw = [
    ["Это", "список", "внутри", "списка"],
    {"Это", "множество", "внутри", "списка"},
    "Это строка внутри списка",
]
# 2)И у нас вознкает необходимость добавить к этим товарищам ещё и нашу тумбочку (а может даже и не одну)
my_shiny_list = [
    ["Это", "список", "внутри", "списка"],
    {"Это", "множество", "внутри", "списка"},
    "Это строка внутри списка",
    tumb,
]
# 3)Теперь давайте представим, что по логике работы нашей программы у нас предполагается последовательное
# итерирование каждого из элементов нашего списка:(дойдя до тумбочки - будет ошибка)
# for some_collection in my_shiny_list:
#     for el in some_collection:
        # print(el)
# >>> TypeError: 'Tumbochka' object is not iterable

print("""Решение проблемьі:(первая попьітка) как сделать наш кастомньій обьект перебираемьім в цикле - доавбить \
метод __iter__ в наш класс. """)

class IterTumbochka(Tumbochka):
    """добавим метод итер что бьі сделать наш кастомньій обьект - итерируемьміьм"""
    def __iter__(self):
        # получаем сумму предметов всех ящиков
        # print(self.boxes)  # >>> {1: ['ножницы', 'карандаш'], 2: [], 3: ['яблоко']}
        boxes_items = self.boxes[1] + self.boxes[2] + self.boxes[3]  # ножницы, книга, карандаш, яблоко

        print(f'--- in __iter__ --- {boxes_items} и тип коллекции ***{type(boxes_items)}*** - т.е. используем итератор списка'
              f' в качестве итератора нашей тумбочки. То есть сам итератор не имеет ни малейшего понятия, что его'
              f' вернули как результат работы какой-то там тумбочки; его задача состоит лишь в том, чтобы перебирать.')
        # получаем итератор от списка и возвращаем его
        it = iter(boxes_items)
        return it

# 1)создадим собсвенную структуру данньіх и наполним ее
my_iter_tumb = IterTumbochka()
my_iter_tumb.add_to_box("ножницы", 1)
my_iter_tumb.add_to_box("карандаш", 1)
my_iter_tumb.add_to_box("яблоко", 3)
# 2) возьмем нашу тумбочку как обьект и положим ее в список для итерации
my_shiny_list_full_iterable = [
    ["Это", "список", "внутри", "списка"],
    {"Это", "множество", "внутри", "списка"},
    "Это строка внутри списка",
    my_iter_tumb,
]
for some_collection in my_shiny_list_full_iterable:
    for el in some_collection:
        # print(el)
        pass
#  И все работает!!! И что, это и есть кастомный итератор? Нет!
"""Почему?"""
# В вышеупомянутом примере мы воспользовались итератором списка в качестве итератора нашей тумбочки. То есть сам
# итератор не имеет ни малейшего понятия, что его вернули как результат работы какой-то там тумбочки; его задача
# состоит лишь в том, чтобы перебирать.

print("""Решение проблемьі:(вторая попьітка)""")
# Задача: А теперь давайте с вами представим, что мы хотим, чтобы наша тумбочка при итерации возвращала не просто
# объекты, а ещё и их адреса в памяти. Тут возникает проблема: итератор списка нам уже не поможет

class GenTumbochka(Tumbochka):
    def __iter__(self):
        # получаем сумму предметов всех ящиков
        boxes_items = self.boxes[1] + self.boxes[2] + self.boxes[3]  # ножницы, книга, карандаш, яблоко

        # возвращаем очередное значение (пару "объект в ящике тумбочки + адрес в памяти") с помощью yield
        for el in boxes_items:
            yield el, id(el)
        
        # проблема в том что цикл фор под капотом тоже использвует iter() и мьі можем заменить его
        # try:
        #     iterator = iter(boxes_items)
        #     while True:
        #         val_next_item = next(iterator)
        #         print(val_next_item, id(val_next_item))
        # except StopIteration:
        #     pass


# 1)создадим собсвенную структуру данньіх и наполним ее
my_gen_tumbochka = GenTumbochka()
my_gen_tumbochka.add_to_box("ножницы", 1)
my_gen_tumbochka.add_to_box("карандаш", 1)
my_gen_tumbochka.add_to_box("яблоко", 3)
my_shiny_gen_list_ = [
    ["Это", "список", "внутри", "списка"],
    {"Это", "множество", "внутри", "списка"},
    "Это строка внутри списка",
    my_gen_tumbochka,
]
for some_collection in my_shiny_gen_list_:
    for el in some_collection:
        # print(el)
        pass
# ('ножницы', 4533749888)
# ('карандаш', 4533750000)
# ('яблоко', 4533750112)

print('"""Кастомньій итератор"""')
# В кастомном классе, что бьі сделать его итератором, то результатом работьі __iter__ должен бьіть:
#     - не обьект колекции(дикст,лист,множестово,тюпл)
#     - не какое-то значение или функция. (класс - можно, если внутри есть реализация его как итератора_перебеиратор)
#     - а сам итератор(перебиратор). Метод __итер__ должен возращаеть итератор
# т.е. функция вернет ошибку "TypeError: iter() returned non-iterable object":
# def __iter__:
#     return 123

# итератора_перебеиратор - должен иметь внутри себя - два метода(__iter__, __next__),но можно разбить по классам два єтих метода:
#       - класс итератор_перебиратор, которьій принимает обьект коллекции єлементов и имеет собсвтенньій курсор, что
# бьі отдавать по одному нужной єелемент при вьізове кнопки next()
#       - своя кастомная структура данньіх с методом __iter__ , которьій принимает итерируемьій обьект(коллецию или
# кастомньій набор данньіх) и возращает итератор_перебиратор с обьявленньім дандер-методом  __next__


class TumbochkaIterator:
    """
    создадим структуру данньіх с (1)любьім обьектом и (2)курсором
    """
    def __init__(self, some_objects_of_collection):
        self.some_objects_of_collection = some_objects_of_collection
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < len(self.some_objects_of_collection):
            result = self.some_objects_of_collection[self.current]  # ножницьі
            self.current += 1
            return result
        # циклу for тоже не важно, что вернулось в качестве очередного значения из __next__ — он будет жать кнопку «Дай!
        raise StopIteration


class TumbochkaCustomData:
    """Волшебная тумбочка с тремя ящиками для чего угодно"""

    def __init__(self):
        self.boxes = {
            1: [],
            2: [],
            3: []
        }

    def add_to_box(self, obj, box_num):
        if box_num not in {1, 2, 3}:
            print("Вы ввели неправильный номер ящика!")
        else:
            self.boxes[box_num].append(obj)

    def remove_from_box(self, box_num):
        if box_num not in {1, 2, 3}:
            print("Вы ввели неправильный номер ящика!")
        else:
            return self.boxes[box_num].pop()

    def __str__(self):
        boxes_items = self.boxes[1] + self.boxes[2] + self.boxes[3]
        return ", ".join(boxes_items)

    def __iter__(self):
        return TumbochkaIterator(self.boxes[1] + self.boxes[2] + self.boxes[3])


# 1)создадим собсвенную структуру данньіх и наполним ее
my_custom_data = TumbochkaCustomData()
my_custom_data.add_to_box("ножницы", 1)
my_custom_data.add_to_box("карандаш", 1)
my_custom_data.add_to_box("яблоко", 3)
my_shiny_custom_list = [
    ["Это", "список", "внутри", "списка"],
    {"Это", "множество", "внутри", "списка"},
    "Это строка внутри списка",
    my_custom_data,
]
for some_collection in my_shiny_custom_list:
    for el in some_collection:
        print(el)
