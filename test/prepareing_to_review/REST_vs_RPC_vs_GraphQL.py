# API - програмный интерфейс для общения компонентов программы друг с другом. Клиент - сервер, в вебе - это общенгие фронта с \
# беком или два бэка между собой. Есть два типа API - это REST и RPC. REST - хорошо кешируемый и не содержит состояние клиента. \
# Т.е. ни сервер ни клиент не знает о состоянии друг друга. В таких API мы напрямую управляем обьектами подобно файловой системе.\
# У таких обьектов есть своя иерархия(структура) - подобно файлам с папками. Например, мы делаем интернет магаз и у нас есть товар
# и мы с ним можем совершать различные действия: доавбить товар в корзину, удалить из ней, переимновать товар, посмотреть\
# описание, цену и прочее...


# REST(repr state transfer) - архитектурный стиль, который описывает то как различные программы могут общаться между собой и \
# представляет собой набор ограничений и требований. Архитектурный стиль - некий шаблон, по которому мы можем построить наше \
# приложение. Если мы построим наше приложение по этому шаблону, тогда это будет RESTful приложение. Клиент(для рест это
# программа) обращается на сервер и получает ответ. REST то альтернатива RPC(remote procedure call) - удаленный вызов процедур, \
# т.е. через одну программу вызываем функцию удаленно на другом компе и получаем результат её работы.
# Т.е. REST это рекомендации, которые говорят использовать в себе стандарты http, url, json, html.
# SOAP - это уже четкий стандарт(протокол, а не рекомендации) обмена СТРУКТУРИРОВАННЫМИ смс(ТОЛЬКО XML), которые, в том числе
# могут вызывать функции или целые скрипты на сервере. Т.е. фактически мы вызываем функцию с набором аргументов и получаем
# результат. SOAP неудобно читать и сообщения очень большие что негативно сказывается на трафике. WSDL схема описывает доступные
# функции на сервер и параметры.
#
#  ТРЕБОВАНИЕ RESTful API:
# 1) client-server -  т.е. общение происходит отдельно между клиентом и отдельно между сервером. Плюсы:
#   - это то что клиенты не связаны с хранением данных, которые есть на сервер. Т.е. сервер имеет все данные, а наши клиенты
# просто запрашивают её.
#   - т.к. они сервер не связан с интерфейсом клиента(его состоянием-сессией), то сервер знает что клиент будет приходить за
# инфой, А НЕ сервер будет распределять её по клиентам. Сервер - главное звена, а все клиенты обращаются за инфой к нему.
# 2) Stateless. ервер не должен хранить какой-либо инфы о клиентах. Т.е. у нас НЕТ логина и пароля, а если нужна индетификация,
# то используем сгенерируемый токен(api_key).
# 3)Cache. Ответ должен иметь отметку - является ли он кешируемым, для предотвращения использования клиентами устаревших данных.
# 4) Uniform Interface. Единый интерфейс, т.е. - это взаимодействия между клиентом и сервером, которое \
# позволяет развиваться независимо друг от друга, пока сервер не обновит это правило. Т.е. клиент может создать другой фронт, но\
# при этому работая с нашими данными. Принципы:
#   - Ресурсом(обьектом) является все то, чему можно дать имя(пользователь, изображение, предмет(майка, погода)), который не \
# должен меняться при изменинии состояния ресурса. Ресурс идентифицируется с URI. Например, у нас есть ресурс(обьект) погода с \
# соответсвующий URL и наш URL не должен меняться при изменении погоды.
#   - Манипуляция над ресурсами должна происходить через представления. Представление(использовать  view и/или url) - это \
# текущее(get) или желаемое(create, delete, update) состояние ресурса(собаки, погоды, пользователя, товара). Т.е. если ресурс это\
# погода, то с помощью представления мы можем создать запись о погоде, обновить некоторую инфу о погоде, удалить и т.д.
#   - *! НЕ должно быть доп.сообщений или кеша для обработки ОДНОГО запроса. Т.е. ОТСУТСТВИЕ  состояния, сохраняемого между
#  запросами к ресурсам. Т.е. когда мы делаем запрос к сервису, примаемы сервис должен видеть это как ПЕРВЫЙ запрос(хоть даже
#  если есть слои). Нас сервис НЕ ДОЛЖЕн хранить какой это запрос и ЧТО БЫЛО ДО ЭТОГО. Это важно для масштабирования \
#  системы(создания новых функций в текущем сервисе).
# 5) Layered System. Можно разделять слои, т.е. если есть наш клиент-сервер и сервер вызывает другой сервер, но с условием, что \
# каждый сервер может видеть компоненты только следующие слоя(не глубже, но труднее дебажить). Например, мы вызываем сервис \
# PayPal, который вызывает сервис Visa, но клиент ничего не должен знать об Visa.
#
# ПРЕИМУЩЕСТВА RESTFful API: (restful сервис должен иметь все это, иначе это не restful)
# - Надежность(за счет отсутвия сохранения инфы о клиенте)
# - Производительность (за счет использования кеша, если одинаковые запросы(дай ссылку на это видео), то можно их кешировать)
# - Масштабируемость(за счет разделения интерфйсов сервера и клиента, может развивать наш сервер отдельно, при этом не ламая
# работу клиент-сервера).Т.е. клиент может обращаться на свой url, который ему нужно, но при этом может добавлять \
# новые функционал(новые url)
# - Прозрачность системы взаимодействия(есть только клиент и сервер, никаких третьих сторон)
# - Простота интерфейсов(один интерфейс через http протокол, запрос - ответ)
# - Портативность компонентов(работа сервера не заточена под одного клиента, т.е если появятся другие клиенты, то - ок)
# - легкость внесения изменений(если фронт-енд сделан под наш сервер и появится другой фронт, который захочет кастомизировать, то
# не придется влезать на наш сервер и полностью переписывать свой фронт, как это с обычным django)


# 1) Что такое GraphQL и примеры использования:
# GraphQL - язык запросов с открытым кодом, но я бы описал его как архитектурный стиль постройки api, т.е. то как мы можем \
# построить соотношение запросов и ответ на эти запросы.
# У REST есть преимущество и в то же время недостаток, его универсальность. Один запрос(endpoint) к ресурсу (модели/ таблице /\
# продукту) - один ответ. Пример приготовления плова через 4 запроса к ресурсам(риса, морковки, кукурузы и гороха). Минус - это 4\
# отдельных запроса, т.е. долгое ожидание. GraphQL решает как раз эту проблему - один КОНКРЕТНЫЙ запрос - один ответ(включая все
#  CRUD(l) действия, что при REST одним запросом все crud - невозможно).
# 2) Четыре основных блока из которых состоит построить:
# - СХЕМА: описывает структуру наших данных, т.е. из чего они состоят, типы полей - то как наши данные будут размещены в бд; это \
# грубо говоря правила игры, т.е. в схеме мы должны прописать его возможность, т.е то, что он может указывать и что он может \
# получать; в схеме можно описывать фильтры, сортировки(если вытягиваем массив, список чего-то) Создание схем происходит с \
# помощью внутреннего языка SDL(schema definition language)
# - ЗАПРОС: обычный пользовательский запрос на который сервер отвечает; Т.Е. ЕСЛИ МЫ ВЫТЯГИВАЕМ С БД НИЧЕГО НЕ ИЗМЕНЯЯ - ЭТО \
# QUERY, ЕСЛИ ЧТО-ТО ИЗМЕНЯЕМ В БД - ЭТО МУТАЦИЯ
# - РАСПОЗНАВАТЕЛЬ(resolves - решает): данные могут иметь зависимости и нужен  для того что бы GraphQL понимал где ему взять \
# данные для ответа на запрос. Т.е. нужно прописать логику как мы будем отвечать пользователю на его запрос; чаше всего \
# использует ID, но можно добавить свои кастомные (для файла - url, для пользователя - email,  страницы - page и т.д.)
# - МУТАЦИЯ: служат для модификации полей в бд. Например, если есть запрос на просто получить данные, то в \
# мутациях мы хотим изменять данные в бд.(cud - без read) - самое главное разные действия (создания, обновления, удаления) \
# можно сделать одним запрос + помнить про permissions. Т.е. ЕСЛИ МЫ ВЫТЯГИВАЕМ С БД НИЧЕГО НЕ ИЗМЕНЯЯ - ЭТО QUERY, ЕСЛИ ЧТО-ТО \
# ИЗМЕНЯЕМ В БД - ЭТО МУТАЦИЯ

# 3) GraphQl vs REST
# GraphQl относительно REST - достаточно новая технология, т.е. не все ресурсы построены по этой технологией.
#             GraphQl                                |                REST
# - вместо работы с жестко установленными            | - Вызывает одну функцию обработчика;
# конечными точками (endpoints), можно               | - Запись данных определяется как HTTP метод (POST)
# получить именно те данные, которые                 |
# нужны.                                             |
# - описание ресурса не связано со способом
# его получение, так как есть прослойка
# GraphQL которая делает всю грязную
# работу.
# - GraphQL не использует url для
# идентификации того, что доступно в API,
# вместо этого используется схема.
# - GraphQL использует множество функций или разные
# бд
# - Для записи меняется слово в запросе
