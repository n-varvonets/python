first = "строка уже задана".count("а")
sec = sum(1 for i in "строка уже задана" if i == "а")
print(first, sec)
# --------------------------
foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
filter1 = list(filter(lambda x: x % 3 == 0, foo))
print(filter1)
print(list(map(lambda x: x * 3 + 20, foo)))
# --------------------------
print(sorted(['s', 'qs', 'sqdqsw', 'ww', "saq", "1"]))
my_lst = [1,4, 5 , 2 , 0]
print(my_lst.sort())
print(my_lst)
my_lst[1] = 8
print(my_lst)
print(my_lst.sort())
# --------------------------
# __init__ vs __new__
# 1 - магический(dunder) должньі присутсвовать в спецификации классов. Т.е. если мьі сделаем __свой_метод__ с 2мя
# нижними подчеркиваниеями - єто будет не андер-метод, потому что ОН НЕ ЗАРЕЗЕРВИВОВАННЬІЙ в пайтоне.
class T:
    def __init__(self, name):
        self.name = name

a = T("Alex")
b = T("Bob")
# фишка класса:
#  - два єтих езкмпляра будут независимьі(запускать в разньіз процессах, наследовать другой класс и получить его методьі тоже)

# данная запись позволяет напрямую обратиться к метода класса  __new__ , обходя конструктор __init__
exm = T.__new__(T)
print(exm)