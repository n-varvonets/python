# RESTdjango предоставляет класс APIView, который является подклассом джанговского View. Главным отличием является:
# - запросы будут экземплярами Request REST framework, а не HttpRequest;
# - ответы будут Response REST framework, место джанговских HttpResponse.
# 1)На первом уровне представлений идут, как и в джанго, функции (FunctionBasedView) для отображения простых запросов(как в  \
# первом уроке), но уже с помощью декоратора @api_view(). умолчанию он использует только метод представляени get().
# 2)GenericAPIView - расширяет класс APIView, реализуя часто повторяющееся поведение. Т.е. если наше представление подходит
# под стандартный шаблон, тогда используем Generic, а если что-то свое инивидуальное, то APIView(как чистый лист бумаги) и
# прописываем всю ту логику, которая нам нужна.
# 3.0) ViewSet - переводится как набор представлений(CRUD), т.е. обьеденения представлений в один класс. Вместо того что бы
# использовать 4 разных представления для одного обьекта(ресурса(юзер, погода, предмет)), мы можем поместить их в один класс.
# Т.е. к пример умы будем работать с одним классом Пользователь, который умеет и создавать, удалять, изменять и выводить всех
# пользователей. ВАЖНОЖ:!!! ViewSet - вместо того что работать с методами(.get() или .post()), мы - будем работать с \
# действиями(.list(), .create(), .retrieve(), update(), destroy()). ViewSet наследуется от APIView -> Veiw.
# 3.1) Есть так же класс GenericViewSet, который наследуется от (GenericAPIView) и предоставляет набор методов get_queryset(), \
# get_object() и другие, при это не реализует их.(нам надо прописать их самим).
# 3.2) Что бы использовать GenericViewSet нам нужно создать миксин, а потом уже наследовать от него
# 3.3) ModelViewSet наследуется(как и GenericViewSet) от GenericAPIView совмещая функционал различных миксинов.
#
# Представления GenericAPIView:
# 1)CreateAPIView:
# - Используется: для создания конечных точек(наших объектов/записей)
# - Предоставляет: обработчик метода post()
# - Расширяет: GenericAPIView, CreateModelMixin
# 2)ListAPIView:
# - Используется: что бы вытянуть список всех элементов нашей таблицы(модели/объекта) в бд
# - Предоставляет: обработчик метода get()
# - Расширяет: GenericAPIView, ListModelMixin
# 3)RetrieveAPIView:
# - Используется: для получение одного объекта/записи
# - Предоставляет: обработчик метода get()
# - Расширяет: GenericAPIView, RetrieveModelMixin
# 4)DestroyAPIView:
# - Используется: для удаления одного объекта/записи
# - Предоставляет: обработчик метода delete()
# - Расширяет: GenericAPIView, DestroyModelMixin
# 5)UpdateAPIView:
# - Используется: для обновления одного объекта/записи
# - Предоставляет: обработчик метода put() и patch()
# - Расширяет: GenericAPIView, UpdateModelMixin
#
# 6+)ListCreateAPIView:
# - Используется: когда нам необходимо - создать или получить набор наших элементов
# - Предоставляет: обработчик метода get() и post()
# - Расширяет: GenericAPIView, ListModelMixin, CreateModelMixin
# 7+)RetrieveUpdateCreateAPIView:
# - Используется: для чтения или обновления экземпляров нашей модели
# - Предоставляет: обработчик метода get() и put(), patch()
# - Расширяет: GenericAPIView, RetrieveModelMixin, UpdateModelMixin
# 8+)RetrieveDestroyACreateAPIView:
# - Используется: для чтения или удаления экземпляров(конечных точек) нашей модели
# - Предоставляет: обработчик метода get() и delete()
# - Расширяет: GenericAPIView, RetrieveModelMixin, DestroyModelMixin
# 8+)RetrieveUpdateDestroyACreateAPIView:
# - Используется: для чтения, обновления или удаления экземпляров нашей модели
# - Предоставляет: обработчик метода get(), put(), patch() и delete()
# - Расширяет: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin


# Менеджер - интерфейс, через который создаются запросы к бд, который нужно в модели переименовать.Служат для того что бы \
# добавлять доп. методы в модель или же изменять базовые вытягиваняия из модели, т.е. изменять базовый queryset

# proxy не изменяет контент пользователя, он только изменяет её поведение, т.е. без создания новой таблицы в бд + можно менять менеджер

# Второй кастомный подход, когда нам необходимо прикреплять картинки/файлы к пользователям или другую доп.инфу.

# class Profile(models.Model):
#     user = models.OneToOneField(User, on_delete=models.CASCADE)  # связь О2О к модели пользователя, что бы создать новую таблицу \
    # с наими данными и ползователь должен быть один.. т.к. нельзя добавить новые поля в User, то просто раширяем его модель добавляя картинки

# Реализован сигнал post_save модели User, т.е. когда у нас создается новый пользователь, новый инстанс модели User вызывает \
# метод модели post_save и вызывается наша функция update_profile_signal
# @receiver(post_save, sender=User)
# def update_profile_signal(sender, instance, created, **kwargs):
#     """
#     Если флажок created создан, то в таком случае мы создаем для него Profile
#     sender - компонент, который посылает сигнал(новый пользователь модели User);
#     receiver - наша функция(update_profile_signal), которая обрабатывает сигнал(создает профиль с o2o)
#     """
#     if created:
#         Profile.objects.create(user=instance)
#         instance.profile.save()


# AbstractBaseUser и AbstractUser самые сложные типы кастомизации модели пользователя(в отличии от proxy или наследования User
# со связью O2O) и нужно продумать наперед перед миграциями. Если есть возможность - необходимо их обходить.

# AbstractBaseUser нуно использовать, когда надо изменить аутентификацию пользователей, или когда нам не подходит стандартный
# процес работы с пользователями. Например, у стандартно процес логина использует имя и пароль, а мы хотим мыло и пароль..
# AbstractBaseUser - совершенно новая модель.(миграции + setting.py)

# AbstractUser - сабклас AbstractBaseUser и его полная версия. Т.е. AbstractBaseUser -> AbstractUser -> Наша_кастомная_модель.
# Её используют, когда нас устраивает аутентификация в джанго, но необходимо добавить доп инфу в модель User, но по каким-то
# причинам мы не хотим создавать доп. класс как в случае с proxy


# темплейты - инструмент, позволяющий добавлять логику, а наш фронтенд не используя js. Темплейт состоит из 4х конструкций: \
# переменные(выводять значения из контекста {{ }}), теги(добавляют логику {% %}), фильтры(преобразуют переменные. фильтры могут
# быть как в тегах {% if element|Length >4 %} то так и в переменных {{ element|Length }}), комментарии{# for example #}.
# Пару примеров фильтров: |Length, |upper, |Linebreaks, |filesizeformat, |join:"_TEST" - больше смотри в документации
# ВАЖНО ПОНИМАТЬ: темплейты используются-выполняются только на этапе рендеринга страницы, если нам необходимо делать какую-то
# логику на уже готовой странице - тогда используется js. Темплейт подойдет для тех проектов, где нет необходимости очень
# сложного фронт-енда. Т.е. для большого проекта используется js.

# Использвание generic - упрощают работу и ускоряют разрабокту. Наследуясь от них у нас уже есть готовые аттрибуты и методы,
# которые просто надо переопределить или использовать подогнать под свою задачу. Их можно разбить на подгруппы:
# 1) Авторизация: 'LoginView', 'LogoutView',  - используются что бы пользователь мог авторизоваться или выйти
# 2) Основные(Base) генерик: (.generic.base import RedirectView, TemplateView, View) 'TemplateView', - вью который описывается \
# ОДНИМ темплейтом, View - парент класс для всех остальных views
# 3)Дитейл:'DetailView' - вывести информацию, по конкретному обьекту конкретной модели с pk
# 'ListView' вывести список записей из одной или нескольких моделей
# 4)Эдит:  м'CreateView', 'UpdateView', 'DeleteView', - они работаю с КОНКРЕТНОЙ моделью для crud функций

# Jinja - инструмент для создания шаблонов(расшираяет синтаксис и возможности оперировать кодом в шаблонах),
# когда нам необходимо какой-то код представить в виде html.
# Для этого в основном используем js, но разработчики создали Jinja что бы использовать его вместо js.
# Jinja является более усовершенствованной версией шаблонов(в основном для создания письма или какой-то документации).
# Есть синтаксис(http://i.imgur.com/NR16Bbh.png), который не разрешен в обычном джанго темплейте, но в jinja - ok. Например:
# - {{ user_data['name'] }} или {{ lipsum(2) }} как в пайтоне... в шаблонизаторе надо было бы {{ user_data.name }} или \
#  использование рандомного текста через {{ lipsum }}
# в Jinja можно создавать макросы, т.е. если у нас есть какой-то код, который повторяется, то можно записать макрос и \
# переиспользовать его. Использовать принцип DRY Грубо говоря это аналоги функций в пайтон. Есть входные данные и что с ними мы \
# будем делать.(http://i.imgur.com/egVKrby.png). И потов коде можем вызвать макрос передавая в него данные.

# Пункты применения отправки писем:
# - Сброс пароля;
# - Информативные письма(обновление всем пользователям или отправка писем администратору при ошибках)
# - Регистрация
# - Оповещения покупателей(акции, сертификаты, промо и др.)

# Пункты применения отправки писем(детальней):
# - 1)Информативные письма(обновление всем пользователям или отправка писем администратору при ошибках). Делел через gmail \
# и aws_adv_it(через внутренний сервис simple_email_confirmation. минус этого что он платный, если хотим отправлять к неопозананным \
# пользователеям(тех что не указали в настройках aws_adv_it, те что не ified by aws_adv_it))
# - 2)Регистрация, а потом активация
# - 3)Оповещения покупателей(акции, сертификаты, промо и др.).т.е. для большого кол-ва пользователей сразу через mailchimp-marketing
# - 4)Сброс пароля; Уже джанго реализовал вью в django.contrib.auth ('reset_password_app.urls') для этого функционала, так что
# с точки зрения бека ничего нового использовать не нужно, только создавть ноый url звать и правильно назвать темлейты(_complite,
# _confirm, _done, _email, _form, _email, _subject.txt(тема письма)) и их переиспользовать. Но что бы мы не исользовали(любые
# внешние библиотеки) - принцип будет одним и тем же:
# - открывает нашу страницу
# - на странице ему необходимо ввести почту
# - он вводит почту и мы на почту ему отправляем ОДНОРАЗОВЫЙ линк с ключом(по кторому будем понимать что конкретно этот \
# пользователь хочет изменить мебе пароль)
# - меняет его и все!


