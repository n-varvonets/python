"""1) Типы данных"""
# НЕИЗМЕНЯМЫЕ: INT FLOAT BOOL NONETYPE TUPLE FROZENSET
# ИЗМЕНЯМЫЕ: LIST DICT SET
"""2)== is"""
# == сравнивает два операнда по значению
# is сравнивает по адресам в памяти
"""3) args vs kwargs"""
# args - аргументы передаются позиционно...
# kwargs - аргументы передаются по ключам
# т.е. аргументы передаются по значениям(НЕИЗМЕНЯМЫЕ) или по ссылкам(ИЗМЕНЯМЫЕ)


def some_function(some_arg: list):
    some_arg.append(1)
    return some_arg


print(some_function([]))
print(some_function([]))

list_ex = []
print(some_function(list_ex))
print(some_function(list_ex))
print(some_function(list_ex))

"""4)lamda функция"""
# lamda функция - анонимная функция, может принимать неограниченное кол-во аргументов и неявный return
some_list = [1, 2.0, 3]
print(list(filter(lambda x: isinstance(x, int), some_list)))

foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]

filter1 = list(filter(lambda x: x % 3 == 0, foo))
print(filter1)

print(list(map(lambda x: x*3+20, foo)))

"""5)OOP"""
# это когда мы свой код выстраиваемый в совокупность объектов, КОТОРЫЕ ЯВЛЯЮТСЯ ОБЬЕКТАМИ КАКОГО-ТО КЛАССА,
# а классы - выстраивают иерархию какого-то наследования
# Принципы:
# абстракция - абстрагируемся от всех характеристик какого-то обьекта и используем в нашем коде только что необходимо
# инкапсуляция - в ооп понимается двуяко и фундмательно от инкапс и второй скорытие данных
# наследование - один класс строится на основе другого..(родительск/дочерний) и дочерний класс получает все характеристики родительского класса
# полиморфизм - (парметрический)в функциях нам ве равно на типы данных которые прилитаеют извне.. главное что бы внутри функции в этом аргументе был реализован весь вфункционал с которым мы работаем

"""генератор"""
# генератор - такая цикл который вместо реткрна использует  yeald(такая вещь которая умеет принимать и отдавать контроль управления)
# отработанный генератор хранить значений в обьекте и методом next отдает след значение
"""корутина - генератор, только в который можно посылать данные с помощью метода сенд """

"""threading, multiproc, asyncio"""
# threading - в рамках одного процесса делим потками.. у потоков есть общая память и нужно ставить ставить блокироваки что они с общей памятью сообща работали
# asyncio - у него есть иввент луп, который проходится по таскам(корутинам).. опрашивает их на выполнение и в зависимости от их ответов будем как-то работать
# GIL - clobal interpreteru lock - это когда в один момент времени может выполняться только один поток

"""testing"""
# по хорошому весь код должен быть покрыть тестами или приблизиться к максимум
# unit тесты это тесты который покрывают какй-то минимальный функционал.. класс.. функцию.. блок какой-то атомарной функции
# функциональный тест - тестирует связку компонетов... ендпоинты
# Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций.

"""best practices"""
# SOLID: (это все про классы)
#   Single responsibility - каждый класс должен выполнять те цели для которых он был задуман
#   Opened/closed - класс должен быть открыть для расширений и закрыт для модификаций
#   барбара липко... - если у нас есть родительский класс и его дочерний класс и у нас есть функция, которая умеет работать с родительским классом и если мы у этого обьекта вызовеим родительский класс, то он должен работать
#   interdface agrigations - чем иметь один здоровый класс, лучше иметь куча мелкий интрфейсов под конкретные нужны
#   dependency inversion -  должны быть зависимости на классах, а не классы на зависмостях
# KISS -
# DRY -
# классный сайт:
# https://refactoring.guru/ru/design-patterns/creational-patterns
