"""1) Типы данных"""
# НЕИЗМЕНЯМЫЕ: INT FLOAT BOOL NONETYPE TUPLE FROZENSET
# ИЗМЕНЯМЫЕ: LIST DICT SET
"""2)== is"""
# == сравнивает два операнда по значению
# is сравнивает по адресам в памяти
"""3) args vs kwargs"""
# args - аргументы передаются позиционно...
# kwargs - аргументы передаются по ключам
# т.е. аргументы передаются по значениям(НЕИЗМЕНЯМЫЕ) или по ссылкам(ИЗМЕНЯМЫЕ)


def some_function(some_arg: list):
    some_arg.append(1)
    return some_arg


print(some_function([]))
print(some_function([]))

list_ex = []
print(some_function(list_ex))
print(some_function(list_ex))
print(some_function(list_ex))

"""4)lamda функция"""
# lamda функция - анонимная функция, может принимать неограниченное кол-во аргументов и неявный return
some_list = [1, 2.0, 3]
print(list(filter(lambda x: isinstance(x, int), some_list)))

foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]

filter1 = list(filter(lambda x: x % 3 == 0, foo))
print(filter1)

print(list(map(lambda x: x*3+20, foo)))

"""5)OOP"""
# это когда мы свой код выстраиваемый в совокупность объектов, КОТОРЫЕ ЯВЛЯЮТСЯ ОБЬЕКТАМИ КАКОГО-ТО КЛАССА,
# а классы - выстраивают иерархию какого-то наследования
# Принципы:
# абстракция - абстрагируемся от всех характеристик какого-то обьекта и используем в нашем коде только что необходимо
# инкапсуляция - в ооп понимается двуяко и фундмательно от инкапс и второй скорытие данных
# наследование - один класс строится на основе другого..(родительск/дочерний) и дочерний класс получает все характеристики родительского класса
# полиморфизм - (парметрический)в функциях нам ве равно на типы данных которые прилитаеют извне.. главное что бы внутри функции в этом аргументе был реализован весь вфункционал с которым мы работаем

"""генератор"""
# генератор - такая цикл который вместо реткрна использует  yeald(такая вещь которая умеет принимать и отдавать контроль управления)
# отработанный генератор хранить значений в обьекте и методом next отдает след значение
"""корутина - генератор, только в который можно посылать данные с помощью метода сенд """

"""threading, multiproc, asyncio"""
# threading - в рамках одного процесса делим потками.. у потоков есть общая память и нужно ставить ставить блокироваки что они с общей памятью сообща работали
# asyncio - у него есть иввент луп, который проходится по таскам(корутинам).. опрашивает их на выполнение и в зависимости от их ответов будем как-то работать
# GIL - clobal interpreteru lock - это когда в один момент времени может выполняться только один поток
# главный минус threading состоит в том что потоки
# выполняются не в один момент времени, а они просто чередуются из-за GIL
"""
Перед тем как поток получает управление - он пытается заблокировать muteX:(
    - если muteX(блокировка) свободная - то он получает управление;
    - если muteX(блокировка) не свободная - то просто уведомляет что хотел бы захватить и потом просто засыпает.
Многопоточная программа последовательно переклюется между этими тредами, а в каждый момент времени может выполняться
только один поток...
Таким образом на выполнение потоков еще накладывается и задержка на:
    - блокировку; wait()
    - на освобождение muteX; release()
    - захват muteX другим потоком... set()
"""
"""
выше мы рассмотрели в модуле threading:
- как запускать
- как использовать виды блокировок (join(),set(),wait(),realise(),lock)
- как использовать потоко-безопасное хранилище
- GIL
"""
#  concurrent.futures использует два вида PoolExecutor потоков и процессов.
"""
В рамках двух процессов будет один механизм GIL, работа которого никак не связана
между друг друг, т.е. условно можно представить что два.  В отличи от четкого
последовательного выполнения потоков в процессе.

Процесс - тяжеловесней потока, его тяжелей запустить по времени, ресурсозатратней, НО..
если есть какая-то ТЯЖЕЛАЯ ЗАДАЧА, то пачка процессов дадут нам больше прироста, чем пачка тредов
"""

"""testing"""
# по хорошому весь код должен быть покрыть тестами или приблизиться к максимум
# unit тесты это тесты который покрывают какй-то минимальный функционал.. класс.. функцию.. блок какой-то атомарной функции
# функциональный тест - тестирует связку компонетов... ендпоинты
# Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций.

"""best practices"""
# SOLID: (это все про классы)
#   Single responsibility - каждый класс должен выполнять те цели для которых он был задуман
#   Opened/closed - класс должен быть открыть для расширений и закрыт для модификаций
#   барбара липко... - если у нас есть родительский класс и его дочерний класс и у нас есть функция, которая умеет работать с родительским классом и если мы у этого обьекта вызовеим родительский класс, то он должен работать
#   interdface agrigations - чем иметь один здоровый класс, лучше иметь куча мелкий интрфейсов под конкретные нужны
#   dependency inversion - должны быть зависимости на классах, а не классы на зависмостях
# KISS -
# DRY -
# классный сайт:
# https://refactoring.guru/ru/design-patterns/creational-patterns

"""нормализация"""
# Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.
# Избыточность устраняется, как правило, за счёт декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на несколько.

# бардо, бэклог, тикеты
# стендап, реторспектива(), груминг(бэклог) и пленнинг

# ERD диаграмма
# строгий и не строгий пайтон джвавасерипт
# recount   когда перечень обьектов равно 0 - это узначает что ты можешь удалятся из памяти

# get django / get
# awasp top 10


# get cwraes fulter
# count versus exists
#
#
# sql:
#     dml and ddl
#     delete удаляет данныее из табл. дроп - удаляет тблицу как сущность

