"""1) Типы данных"""
# НЕИЗМЕНЯМЫЕ: INT FLOAT BOOL NONETYPE TUPLE FROZENSET
# ИЗМЕНЯМЫЕ: LIST DICT SET
"""1.a)Коллекция и for in"""
# Коллекция - (1)набор єлементов (2)произвольного типа.
#   - Упордочньіе  коллекции - єлемент МОЖНО взять по индексу.(list или tuple/кортеж):
l = [0, 1, 2, 3, 4, 5]
t = (0, 1, 2, 3, 4, 5)
#   - НЕупордочньіе  коллекции - єлемент НЕЛЬЗЯ взять по индексу.(set/множество или dict/словарь):
s = {0, 1, 2, 3, 4, 5}
d = {0: '-', 1: 'a', 2: 'b', 3: 'c'}
"""1.б)Проблема коллекции - для всех коллекций нужен свой метод метод обхода єлементов в цикле"""
# №1. Обойти коллекцию без for.  (для упорядоченной коллекции)
cnt = 0
size = len(l)
while cnt < size:
    print(l[cnt])
    cnt += 1
# №2. Обойти коллекцию без for.  (для НЕупорядоченной коллекции - для словаря нужно писать отдельно)
while cnt < size:
    print(s.pop())
    cnt += 1
# №3. Обойти коллекцию без for.  (для НЕупорядоченной коллекции - для словаря)
print('---dict---')
size_for_dict = len(d)
# через pop() - не получится + нужно проитерироваться по ключам...  сначала заберем ключи из словаря:
keys_d = list(d.keys())
while cnt < size_for_dict:
    # print(d.pop())
    print(keys_d[cnt])
    cnt += 1
"""1.в)ЦИКЛ for - синтаксическая конструкция, которая позволяет для любой коллекций использовать волшебньій способ обхода ПОСЛЕДОВАТЕЛЬНО"""
print('-----dict for in-------')
for el in d:
    print(el, f'val = {d[el]}')
"""1.Принцип работьі цикла for"""
# 1.a) Обічно нам рассказівают: цикл for берет и перебирает наш список. - єто обман и провокация!
# на самом деле он работает с итератом обьекта коллекции любого типа.
# Под капотом он сначала принимает коллекцию и отдает итератор, а потом при помощи next() перебирает его.
try:
    """ЦИКЛ FOR под капотом"""
    iterator = iter(l)
    while True:
        print(next(iterator))
except StopIteration:
    pass
"""что такое итератор?"""
# Итератор - обьект, которьій описьівает правила, по которьім будет происходит итерироватция нашей коллекции
"""2)== is"""
# == сравнивает два операнда по значению
# is сравнивает по адресам в памяти
"""3) args vs kwargs"""
# args - аргументы передаются позиционно...
# kwargs - аргументы передаются по ключам
"""4)lamda функция"""
# lamda функция - анонимная функция, может принимать неограниченное кол-во аргументов и неявный return
some_list = [1, 2.0, 3]
print(list(filter(lambda x: isinstance(x, int), some_list)))
foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
filter1 = list(filter(lambda x: x % 3 == 0, foo))
print(filter1)
print(list(map(lambda x: x*3+20, foo)))
"""5)OOP"""
# это когда мы свой код выстраиваемый в совокупность объектов, КОТОРЫЕ ЯВЛЯЮТСЯ ОБЬЕКТАМИ КАКОГО-ТО КЛАССА,
# а классы - выстраивают иерархию какого-то наследования
# Принципы:
# - абстракция - абстрагируемся от всех характеристик какого-то обьекта и используем в нашем коде только что необходимо
# - инкапсуляция - в ооп понимается двуяко и фундмательно от инкапс и второй скорытие данных
# - наследование - один класс строится на основе другого..(родительск/дочерний) и дочерний класс получает все характеристики родительского класса
# - полиморфизм - В буквальном значении полиморфизм означает множество форм. (парметрический)в функциях - нам все равно
# на типы данных которые прилитаеют извне.. главное что бы внутри функции был реализован весь вфункционал с которым мы работаем
# 1.оператора сложения - print(num1 + num2), print(str1+" "+str2)
# 2.на примере функции len():
# print(len("Programiz"))   # >>> 9 (str)
# print(len(["Python", "Java", "C"]))   # >>> 3 (list)
# print(len({"Name": "John", "Address": "Nepal"}))   # >>> 2 (dict)
# Мы можем использовать идею полиморфизма для методов класса, так как разные классы в Python могут иметь
# методы с одинаковым именем. Позже мы сможем обобщить вызов этих методов, игнорируя объект, с которым мы работаем

"""threading, multiproc, asyncio"""
# threading - в рамках одного процесса делим потками.. у потоков есть общая память и нужно ставить ставить блокироваки что они с общей памятью сообща работали
# asyncio - у него есть иввент луп, который проходится по таскам(корутинам).. опрашивает их на выполнение и в зависимости от их ответов будем как-то работать
# GIL - clobal interpreteru lock - это когда в один момент времени может выполняться только один поток
# главный минус threading состоит в том что потоки
# выполняются не в один момент времени, а они просто чередуются из-за GIL
"""
Перед тем как поток получает управление - он пытается заблокировать muteX:(
    - если muteX(блокировка) свободная - то он получает управление;
    - если muteX(блокировка) не свободная - то просто уведомляет что хотел бы захватить и потом просто засыпает.
Многопоточная программа последовательно переклюется между этими тредами, а в каждый момент времени может выполняться
только один поток...
Таким образом на выполнение потоков еще накладывается и задержка на:
    - блокировку; wait()
    - на освобождение muteX; release()
    - захват muteX другим потоком... set()
"""
"""
выше мы рассмотрели в модуле threading:
- как запускать
- как использовать виды блокировок (join(),set(),wait(),realise(),lock)
- как использовать потоко-безопасное хранилище
- GIL
"""
#  concurrent.futures использует два вида PoolExecutor потоков и процессов.
"""
В рамках двух процессов будет один механизм GIL, работа которого никак не связана
между друг друг, т.е. условно можно представить что два.  В отличи от четкого
последовательного выполнения потоков в процессе.

Процесс - тяжеловесней потока, его тяжелей запустить по времени, ресурсозатратней, НО..
если есть какая-то ТЯЖЕЛАЯ ЗАДАЧА, то пачка процессов дадут нам больше прироста, чем пачка тредов
"""

"""gen_obj/iterator(перебиратор)/iter object"""
# Зачем генераторьі?
# 1)Генераторьі используем там где ЗАРАНЕЕ НЕИЗВЕСТВОМ КОЛИЧСВОМ єлементов последовательности.
# 2) генератор - єто полноценньій обьект, которьій внутри себя содержит правила, что бьі получить очередной єелемент
# последовательности. Т.е. при віьзове функции с yield - возращает обьект генератора,  которьій мало весит и которьій передается
# в функции next()
# - Генератор - поодвид итератора, єлементами которого можно 1)итерироваться и 2)только один раз. Т.е. обьект генератора должен иметь метод реализована next()
# - Итератор - обьект, которий 1)поддерживает функию next() благодаря методу __итер__ 2)помнит какой будет следующий єелемент коллекции"""
# - Итерируемий обьект (range(1, 6) или list,dict,...))  - обьект коллекции по которому можно 1)поочердно  пройтись и 2)может бить преобразован к итератору
# - Итерируемьій обьект - не итератор, так как не поддерживает функцию __next__,но внутри должен иметь метод __iter__
# - Итерируемьій обьект можно спокойно сделать итератором - прокинуть итерируемьій обект в iter()
# - Генератор СРАЗУ является итератором и к нему СРАЗУ можно вьізвать функцию next()."""
# - Корутина - генератор, только в который можно посылать данные с помощью метода сенд
# 3) genarator vs iterator:  во внутреннем методе __iter__:
#    - iterator использует return
#    - generator использует yeild

"""testing"""
# по хорошому весь код должен быть покрыть тестами или приблизиться к максимум
# unit тесты это тесты который покрывают какой-то минимальный функционал.. класс.. функцию.. блок какой-то атомарной функции
# функциональный тест - тестирует связку компонетов... ендпоинты
# Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций.

"""Аутентификация vs Авторизация:"""
# - Аутентификация: мы стараемся понять, что это за пользователь, есть ли он в нашей базе;
# - Авторизация: функционал, который предоставляет права пользователю, т.е рассматриваем какой доступ \
# мы можем дать этому пользователю.

"""Метаклассы"""  # class ...(type)- шаблон для классов и используется для того что бьі перехватить создание класса и его как-то изменить.
# Вьіделяют в метаклассах 4 метода:
#   - __new__ создает єкземпляр класса(обьект). вьізьівается перед __инит__.т.е. можно удобно нам проинициализировать значения еще до его самого создания.
#   - __prepare__ подготавливает данньіе, которьіе потом попдаюат в __new__
#   - __init__ отвечает за инициализацию обьекта/инстанса_класса(параметрьі которіе будем передавать)
#   - __call__ работает тогда, когда мьі вьізьіваем наш класс как функцию. т.е. отвечает за создание обьекта класса. Я __call__ использовал для создания синглтона.
#  В 95% в метаклассах переопределяется метод __new__. Потому что можно перехвать создание класса и что-то в нем изменить(переписать методьі аттрибутьі)

"""best practices"""
# SOLID: (это все про классы)
#   Single responsibility - каждый класс должен выполнять те цели для которых он был задуман
#   Opened/closed - класс должен быть открыть для расширений и закрыт для модификаций
#   барбара липко... - если у нас есть родительский класс и его дочерний класс и у нас есть функция, которая умеет работать с родительским классом и если мы у этого обьекта вызовеим родительский класс, то он должен работать
#   interdface agrigations - чем иметь один здоровый класс, лучше иметь куча мелкий интрфейсов под конкретные нужны
#   dependency inversion - должны быть зависимости на классах, а не классы на зависмостях
# KISS -
# DRY -
# классный сайт:
# https://refactoring.guru/ru/design-patterns/creational-patterns


"""нормализация"""
# Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.
# Избыточность устраняется, как правило, за счёт декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на несколько.

# КАК РАБОТАЕТ ИНТЕРНЕТ? от момента нажатия
# ответ: https://www.youtube.com/watch?v=g94j-ahVR78&t=103s

# бардо, бэклог, тикеты
# стендап, реторспектива(), груминг(бэклог) и пленнинг

# ERD диаграмма
# строгий и не строгий пайтон джвавасерипт
# recount   когда перечень обьектов равно 0 - это узначает что ты можешь удалятся из памяти

# get django / get
# awasp top 10


# get cwraes fulter
# count versus exists
#
#
# sql:
#     dml and ddl
#     delete удаляет данныее из табл. дроп - удаляет тблицу как сущность

