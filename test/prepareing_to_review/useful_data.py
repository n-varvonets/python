"""1) Типы данных"""
# НЕИЗМЕНЯМЫЕ: INT FLOAT BOOL NONETYPE TUPLE FROZENSET
# ИЗМЕНЯМЫЕ: LIST DICT SET  (т.е. можно сделать CRUD значений и как обьект - он останется прежним)
"""1.a)Коллекция и for in"""
# Коллекция - (1)набор єлементов (2)произвольного типа.
#   - Упордочньіе  коллекции - єлемент МОЖНО взять по индексу.(list или tuple/кортеж):    (дело - ссіьлочное и не аллоцирует память)
l = [0, 1, 2, 3, 4, 5]  # (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
t = (0, 1, 2, 3, 4, 5)  # (1)NOT mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
#   - НЕупордочньіе  коллекции - єлемент НЕЛЬЗЯ взять по индексу.(set/множество(неупорядочная коллеция уникальньіх елементов) или dict/словарь):
s = {0, 1, 2, 3, 4, 5}  # (1)mutable, (2)NOT ordered, (3)NOT indexing, (4)ability to have duplicates - NO
d = {0: '-', 1: 'a', 2: 'b', 3: 'c'}  # # (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
"""1.б)Проблема коллекции - для всех коллекций нужен свой метод метод обхода єлементов в цикле"""
# №1. Обойти коллекцию без for.  (для упорядоченной коллекции)
cnt = 0
size = len(l)
while cnt < size:
    print(l[cnt])
    cnt += 1
# №2. Обойти коллекцию без for.  (для НЕупорядоченной коллекции - для словаря нужно писать отдельно)
while cnt < size:
    print(s.pop())
    cnt += 1
# №3. Обойти коллекцию без for.  (для НЕупорядоченной коллекции - для словаря)
print('---dict---')
size_for_dict = len(d)
# через pop() - не получится + нужно проитерироваться по ключам...  сначала заберем ключи из словаря:
keys_d = list(d.keys())
while cnt < size_for_dict:
    # print(d.pop())
    print(keys_d[cnt])
    cnt += 1
"""1.в)ЦИКЛ for - синтаксическая конструкция, которая позволяет для любой коллекций использовать волшебньій способ обхода ПОСЛЕДОВАТЕЛЬНО"""
print('-----dict for in-------')
for el in d:
    print(el, f'val = {d[el]}')
"""1.Принцип работьі цикла for"""
# # 1.a) Обічно нам рассказівают: цикл цикл for позволяет перебирать объекты коллекций. Это правда. Однако часто из
# внимания упускают то, как именно он это делает. на самом деле он работает с итератом обьекта коллекции любого типа.
# Под капотом он сначала принимает коллекцию и отдает итератор, а потом при помощи next() перебирает его.
try:
    """ЦИКЛ FOR под капотом"""
    iterator = iter(l)
    while True:
        print(next(iterator))
except StopIteration:
    pass
"""что такое итератор?"""
# Итератор - обьект, которьій описьівает правила, по которьім будет происходит итерироватция нашей коллекции.
# Что бьі применить метод iter() к обьекту l, то обьект l должен иметь в себе метод __iter__, которьій
# возращает ВСЕГДА СЕБЯ! А потом вьізваем кнопку next() со своей логикой.
"""2)== is"""
# == сравнивает два операнда по значению
# is сравнивает по адресам в памяти
"""3) args vs kwargs"""
# args - аргументы передаются позиционно...
# kwargs - аргументы передаются по ключам
"""4)lamda функция"""
# lamda функция - анонимная функция, может принимать неограниченное кол-во аргументов и неявный return
some_list = [1, 2.0, 3]
print(list(filter(lambda x: isinstance(x, int), some_list)))
foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
filter1 = list(filter(lambda x: x % 3 == 0, foo))
print(filter1)
print(list(map(lambda x: x*3+20, foo)))
"""Итерпретатор vs кампилятор"""
# 1.1.)Интерпритатор - прослойка между кодом и оборудьіваниемна котором воспроизводится программа
# 1.2.)Кампилятор перед запуком проверяет код на:
#     - типов данньіх,
#     - синтасис: скобки, отсупьі
#     - математические вьічисления: 1 / 0
# И если случается что-то нехорошое, то он даже не начинает преобразование в машинньій байт-код.
# 1.3)байт-код - независимая от платвормьі низкоуровневая запись программьі
# 1.4)Зачем __pycache__ ? Кампиялтор видит что кодовая база не менялась, то при запуске, он сразу отправяет его
# виртуальной машине без тратьі времени на преобразование кода в байт напрямую
#
# 2.1)Несмотря на то что Python - язьік интерпритуруемьій, вно в составе интерпретатора есть компилятор, НО ...
# обрезанньій по функцилналу:
#     - проверяет ТОЛЬКО синтаксиеские косяки: скобки, отсупьі и т.д.
#     - НЕ проверяет математические косяки и типизацию
# 2.2)flow: Запуск программьі
# 2.2.1)Мьі говорим интерпритатору - пойди запусти кодовую базу .ру и отправляет его в кампилятор.
# 2.2.2)Дальше кампилятор преобразует кодовую базу в байт-код
# 2.2.2)Дальше кампилятор складьівает байт-код в __pycache__
# 2.2.2)Дальше байт-код общается непосредственно с железом и вьіполняется им же
#
# 3.1.а)Кейс 1: математическую и типизированную ошибку - питоновский кампилятор скушает, станет преобразовьівать данньіе
# в байт командьі и начнет его вьіполнение. В момент ошибки типа или математики, питоновский кампилятор обработает его и
# вернет обратно ошибку в терминал
# print(123)
# 1 / 0
# 3.1.б) Результат: стек трейс сначала принтанет 123, а потом прокинет в терминал ошибку
# 3.2.а)Кейс 2: синтаксическую - кампилятор сразу кинет ошибку и не станет даже преобразовьівать код в байт
# print(123)
# a = a s
# 3.2.б) Результат: в стек трейсе только ошибка без отпринтованнного 123
"""5)OOP"""
# это когда мы свой код выстраиваемый в совокупность объектов, КОТОРЫЕ ЯВЛЯЮТСЯ ОБЬЕКТАМИ КАКОГО-ТО КЛАССА,
# а классы - выстраивают иерархию какого-то наследования
# Принципы:
# - абстракция - абстрагируемся от всех характеристик какого-то обьекта и используем в нашем коде только что необходимо
# - инкапсуляция - в ооп понимается двуяко и фундмательно от инкапс и второй скорытие данных
# - наследование - один класс строится на основе другого..(родительск/дочерний) и дочерний класс получает все характеристики родительского класса
# - полиморфизм - В буквальном значении полиморфизм означает множество форм. (парметрический)в функциях - нам все равно
# на типы данных которые прилитаеют извне.. главное что бы внутри функции был реализован весь вфункционал с которым мы работаем
# 1.оператора сложения - print(num1 + num2), print(str1+" "+str2)
# 2.на примере функции len():
# print(len("Programiz"))   # >>> 9 (str)
# print(len(["Python", "Java", "C"]))   # >>> 3 (list)
# print(len({"Name": "John", "Address": "Nepal"}))   # >>> 2 (dict)
# Мы можем использовать идею полиморфизма для методов класса, так как разные классы в Python могут иметь
# методы с одинаковым именем. Позже мы сможем обобщить вызов этих методов, игнорируя объект, с которым мы работаем
"""метод класса vs staticmethod  vs classmethod"""
# - метод класса: примменяю тогда, когда я знаю работаю ИМЕННО с обьектом класса
# - staticmethod: сделан исключительно для удобвства, что бьі не тратить строчки про импорте в другом модуле
# - classmethod: Используется в том случае, если есть привязка к полям САМОГО класса из которого делается вьізов. Что б
# не біьло проблем при наследовании и дает возможность динамически прокидьівать класс при вьізове, а не хардкорно его
# указав в Роидетельском, а в дочерном придется переопределять все методьі и помнить об єтом

"""threading, multiproc, asyncio"""
# threading - в рамках одного процесса делим потоки.. у потоков есть общая память и нужно ставить ставить блокироваки что они с общей памятью сообща работали
# asyncio - у него есть иввент луп, который проходится по таскам(корутинам).. опрашивает их на выполнение и в зависимости от их ответов будем как-то работать
# GIL - clobal interpreteru lock - это когда в один момент времени может выполняться только один поток
# главный минус threading состоит в том что потоки выполняются в один момент времени конкрирует за работу cpu-задачи

# Перед тем как поток получает управление - он пытается заблокировать muteX:(
#     - если muteX(блокировка) свободная - то он получает управление;
#     - если muteX(блокировка) не свободная - то просто уведомляет что хотел бы захватить и потом просто засыпает.
# Многопоточная программа последовательно переклюется между этими тредами, а в каждый момент времени может выполняться
# только один поток...
# Таким образом на выполнение потоков еще накладывается и задержка на:
#     - блокировку; wait()
#     - на освобождение muteX; release()
#     - захват muteX другим потоком... set()

#  concurrent.futures использует два вида PoolExecutor потоков и процессов.

# В рамках двух процессов будет один механизм GIL, работа которого никак не связана
# между друг другом

# Процесс - тяжеловесней потока, его тяжелей запустить по времени, ресурсозатратней, НО..
# если есть какая-то ТЯЖЕЛАЯ ЗАДАЧА, то пачка процессов дадут нам больше прироста, чем пачка тредов


"""gen_obj/iterator_перебиратор/iter object"""
# Зачем генераторьі?
# 1)Генераторьі используем там где ЗАРАНЕЕ НЕИЗВЕСТВОМ КОЛИЧСВОМ єлементов последовательности.
# 2) генератор - єто полноценньій обьект, которьій внутри себя содержит правила, что бьі получить очередной єелемент
# последовательности. Т.е. при віьзове функции с yield - возращает обьект генератора,  которьій мало весит и которьій передается
# в функции next()
# - Генератор - поодвид итератора, єлементами которого можно 1)итерироваться и 2)только один раз. Т.е. обьект генератора должен иметь метод реализована next()
# - Итератор с точки зрения питона - тот обьект, у которого обьявлен дандер метод __iter__  и __next__. При том __iter__ должен возращать сам себя.
# - Итерируемий обьект (range(1, 6) или list,dict,...))  - обьект коллекции по которому можно 1)поочердно  пройтись и 2)может бить преобразован к итератору
# - Итерируемьій обьект - не итератор, так как не поддерживает функцию __next__,но внутри должен иметь метод __iter__
# - Итерируемьій обьект можно спокойно сделать итератором - прокинуть итерируемьій обект в iter()
# - Генератор СРАЗУ является итератором и к нему СРАЗУ можно вьізвать функцию next()."""
# - Корутина - генератор, только в который можно посылать данные с помощью метода сенд
# 3) genarator vs iterator:  в нашей структуре данньіх(коллекции или кастомном классе) во внутреннем методе __iter__:
#    - iterator использует return
#    - generator использует yeild
"""Кастомньій итератор.Зачем?"""
# Мьі написали свой кастомньій класс(СВОЮ СТРУКТУРУ ДАННЬІХ) и нам возникает потребность ее перебирать.
# Необходимость написания кастомного итератора возникает тогда, когда мы хотим тонко управлять процессом перебора.
# Например, иметь возможность при каком-то событии начать итерацию с самого начала или установить значение указателя
# перебора на определённый элемент.То есть не перебирать всё подряд, как в цикле for, а управлять вручную нашим
# процессом через непосредственное взаимодействие с итератором.
"""Вопрос: Как мне перебирать собственньій обьект?"""
# Есть итерируемый класс и тот, который реализует протокол итерации
#   - перебираемьій обьект: мешок картошки (ТУТ ТОЛЬКО ДАННЬІЕ, кторьіе НЕ ЗНАЮТ кто и как из будет перебирать);
#   - перебиратор или же итератор(его частньій случай - генератор): человек, которьій будет перебирать (ТУТ ТОЛЬКО
# ПРАВИЛА ПЕРЕБИБОРА, которьіе НЕ ЗНАЮТ что ему придется перебирать). т.е. некий объект, который в себе реализует
# интерфейс(т.е. в себе описывает правило) перебора чего-либо.
"""Кастомньій итератор_перебиратор?"""
# В кастомном классе, что бьі сделать его итератором, то результатом работьі __iter__ должен бьіть:
#     - не обьект колекции(дикст,лист,множестово,тюпл)
#     - не какое-то значение или функция. (класс - можно, если внутри есть реализация его как итератора_перебеиратор)
#     - а сам итератор(перебиратор). Метод __итер__ должен возращаеть итератор
# т.е. функция вернет ошибку "TypeError: iter() returned non-iterable object":
# def __iter__:
#     return 123
# итератора_перебеиратор - должен иметь внутри себя - два метода(__iter__, __next__),но можно разбить по классам два єтих метода:
#       - класс итератор_перебиратор, которьій принимает обьект коллекции єлементов и имеет собсвтенньій курсор, что
# бьі отдавать по одному нужной єелемент при вьізове кнопки next()
#       - своя кастомная структура данньіх с методом __iter__ , которьій принимает итерируемьій обьект(коллецию или
# кастомньій набор данньіх) и возращает итератор_перебиратор с обьявленньім дандер-методом  __next__

"""testing"""
# по хорошому весь код должен быть покрыть тестами или приблизиться к максимум
# unit тесты это тесты который покрывают какой-то минимальный функционал.. класс.. функцию.. блок какой-то атомарной функции
# функциональный тест - тестирует связку компонетов... ендпоинты
# Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций.

"""Аутентификация vs Авторизация:"""
# - Аутентификация: мы стараемся понять, что это за пользователь, есть ли он в нашей базе;
# - Авторизация: функционал, который предоставляет права пользователю, т.е рассматриваем какой доступ \
# мы можем дать этому пользователю.

"""Метаклассы"""  # class ...(type)- шаблон для классов и используется для того что бьі перехватить создание класса и его как-то изменить.
# Вьіделяют в метаклассах 4 метода:
#   - __new__ создает єкземпляр класса(обьект). вьізьівается перед __инит__.т.е. можно удобно нам проинициализировать значения еще до его самого создания.
#   - __prepare__ подготавливает данньіе, которьіе потом попдаюат в __new__
#   - __init__ отвечает за инициализацию обьекта/инстанса_класса(параметрьі которіе будем передавать)
#   - __call__ работает тогда, когда мьі вьізьіваем наш класс как функцию. т.е. отвечает за создание обьекта класса. Я __call__ использовал для создания синглтона.
#  В 95% в метаклассах переопределяется метод __new__. Потому что можно перехвать создание класса и что-то в нем изменить(переписать методьі аттрибутьі)

"""best practices"""
# SOLID: (это все про классы)
#   Single responsibility - каждый класс должен выполнять те цели для которых он был задуман
#   Opened/closed - класс должен быть открыть для расширений и закрыт для модификаций
#   барбара липко... - если у нас есть родительский класс и его дочерний класс и у нас есть функция, которая умеет работать с родительским классом и если мы у этого обьекта вызовеим родительский класс, то он должен работать
#   interdface agrigations - чем иметь один здоровый класс, лучше иметь куча мелкий интрфейсов под конкретные нужны
#   dependency inversion - должны быть зависимости на классах, а не классы на зависмостях
# KISS -
# DRY -
# классный сайт:
# https://refactoring.guru/ru/design-patterns/creational-patterns


"""Реляц бд """
# Реляц бд - условно файл или несколько(тестовая(для тестирования), прод(рабочая), дев(для разарбоки) и т.д.)
# на компе(сервер), где хранятся множество таблиц...нашей актуальной и нужной инфьі.
# И всем єтми управляет СУБД - т.е. мьі говорим системе, а система уже сама управляет єтими таблицами(crud).
# Производители СУБД:
#       - Oracle(плантньій - минус, но очень бьісрьій и умньій);
#       - PostrgreSQL(free);
#       - MySQL(fre);
""" Почему реляционная"""
# Потому что она состоит из мноежства таблиц состоящих из горизонтальньіх записей(строк) и вертикальіх полей(столбцов) таблицьі.
# WARN:Столбец(или набор стобцоі) - с их помощью можно ЯВНО определять ТОЛЬКО ОДНУ  уникальную СТРОЧКУ(запись) в таблице - PK или id
"""ER диаграмма"""
# ER диаграмма - нужен для создания связей таблиц в бд
# Редакторы БД
# https://dbdesign.online/
# https://www.dbdesigner.net/
# https://www.lucidchart.com/pages/ente...
# https://sqldbm.com/Home/
""" погружение в ForeignKey"""
# Пример: Табл.1.Аналитика по филиам - (1)где уникальная строчка - несколько стоблцов(id_filial,period) (2)опеделяют инфу других стоблцов(avg_pers_cnt, sum_in, sum_out):
# |--------------------------------------------------------|
# | id_filial |  period  | avg_pers_cnt | sum_in | sum_out |
# |     1     | jun_2018 |      11      | 30_000 | 120_000 |
# |     2     | jun_2018 |      15      | 39_000 | 155_000 |
# |     3     | jun_2018 |      17      | 41_000 | 177_000 |
# |     1     | aug_2018 |      12      | 24_000 | 109_000 |
# |     2     | aug_2018 |      14      | 29_000 | 133_000 |
# |--------------------------------------------------------|
# WARN:Столбец(или набор стобцоі) значения которого ссьілаются на первичньій ключ другой таблицьі - FK(id_smth),
# которьій ТАК ЖЕ (2)опеделяют инфу других стоблцов. Т.е. если указать в классе фильмьі поле категория как FK, то
# мьі ожидаем что у фильма будет СПИСОК категорий, которьій можно вьібрать.
# Пример: Табл.1.Сотрудников                                 Пример: Табл.1.Автомобили отрудников
# |-----------------------------------|                     |-------------------------------------------|
# | id |     name       |   birthday  |                     | id | id_pers |     nomer     |    model   |
# | 1  |     Варвонец   |   03_12_96  |                     | 1  |    1    |     A123BH    |   Audi A4  |
# | 2  |     Иванов     |   12_03_96  |                     | 2  |    2    |     T463AY    |    BMW X3  |
# | 3  |     Никитин    |   25_03_92  |                     | 4  |    2    |     B859PH    |  Ford Fiat |
# | 4  |    "Первьій"   |   25_03_92  |                     | 5  |    3    |     C613AA    |   Mazda A4 |
# | 5  |     Орешкин    |   25_03_92  |                     | 6  |    5    |     A248BH    |   Audi A3  |
# |-----------------------------------|                     |-------------------------------------------|
# WARN:У Иванова - мещаниьі, в то время как у "Первого" - нет машин

"""Категории sql - т.е. группьі команд:"""
# |------------------------------------------------------------------------------------------------------------------|
# |   1) DML(data manipulating language)               |     2) DDL(data defention language)                         |
# | для работьі С ДАННЬІМИ таблицьі(NotCRUD=SIUD)      |    для работьі С САМОЙ таблицьі(NotCRUD=CAD)                |
# |     - select - вьіборка(получение) данньіх         |           - create - создание обьекта(таблиц или самой БД   |
# |     - insert - вставка данньіх                     |           - alter  - реадктирование обьекта(добавить  коло- |
# |     - update - редактирование(измениние) данньіх   |     ку или изменить тип столбца и т.д.)                     |
# |     - delete - удаление(строчек) данньіх           |           - drop  - удаление обьеккта                       |
# |------------------------------------------------------------------------------------------------------------------|
# |   3) TCL(transaction controllanguage)              |     4) DCL(data control language)                           |
# | командьі управдлние с тразцаксциями(2 шт):         |    командьі управдлние доступа к обьекту (2 шт.)            |
# |     - commit -                                     |           - дать досуп(привилиегие)                         |
# |     - rollback                                     |           - убрать доатсуп(привилиегие)                     |
# |------------------------------------------------------------------------------------------------------------------|
"""Пример оператора select(его опции)"""
# SELECT <Стоблец1>,  <Стоблец2>, ..., *,  <СтоблецN>
#    EXTRACT(<столбец> FROM <таблица>) AS <новое название стобдца>
#        FROM <Имя таблицьі>
#           JOIN-ьі <Соеденение дополнительньіх таблиці>
#        WHERE <Условия отбора данньіх из таблицьі>

#        GROUP BY  <Признак групировки >
#        HAVING  <Условия отбора на основе данньіх группировки>

#        ORDERED BY <Столблец1>

#    UNION or UNION ALL (и дальше  след sql-request)

# JOIN-ьі - возможность вьібора данньіх одновременно из нескольких таблиц ((1)ифна клиент и (2)купленньій товар):
#    - т.е. ПОЧТИ ВСЕГДА вьіборку из одной таблицьі нужно дополнять вьіборкой из другой таблицьі ПО КАКОМУ-ТО признаку
#    - 5 видьі джинов:
#           - inner(по внутренним совпалением c существующими значениями),
#           - left(если в лефт строке пусто, то все равно sql оставит его, не пропуская, т.е. левая таблица будет
#           втіваедена полностью) Пример: левая таблица сотрудников, а правая из телефоньі(у сотрудника может бьіть
#           как не сколько, так и не бьіть вовсе. Вот при лефт джине хоть у сотрудника не будет не будет телефона,
#           то он все равно вьіведится) Т.е. к основной таблице пробуем подседенить второстепенную(опционально)
#           - right(по причине left джина - почти не используется, т.к. всегда пьітаемся опционально к основной присоеденить вторестепенную)
#           - full join
#           - cross join
#    - Задача:("https://ibb.co/9YhrDND")
# EXTRACT .. AS ... - можно задавть Алиасьі(новіе имена) столбцов.
# Будь аккуретен и не используй новьій Алиас в с самом поиске(єтот Алиас появится в новой таблице -  В САМЬІЙ
# ПОСЛЕДНИЙ МОМЕНТ и ео использовать можно только блоке OERDER BY) ("https://ibb.co/d4NWqb7" - "https://ibb.co/3kG3FZS")
# WARN:Порядокц опций(команд)  SELECT - ВАЖЕН
# WHERE - получает данньіе из таблицьі по условию, а потом если нужно, то данньіе сгрупировуем(обобщенньій итог):
#       - операторьі сравнения:[(<>, !=, НЕравно), (=, (>, >=, <, <=) ]
#       - и/или: OR , AND
#       - входит в состав или нет(не одно из них):IN (1,2, ...), NOT IN (1, 4, ...)
#       - найти по тексту: name = 'Иванов'
#       - найти по куску текста, к примеру:
#               - слева и справа ожидаю значения: name LIKE '%Иванов%'
#               - начинается со слова:
#                       - name LIKE 'Иванов%'
#                       - upper(name) LIKE 'A%'
#               - слева и справа ожидаю значения + общий фрагемент заканчивается на "ч": name LIKE 'Иванов%ч'
#               - задать макску с условно неважньми сиволами: name LIKE '+380__12356'  # _ - можно подсвтаить люьой символ
#               - работа с НЕИЗВЕСТНЬІМИ данньіми:
#                       - сущесвтвуют или есть значения: cook_id > 0, cook_id IS NOT NULL
#                       - строчки строчки, у которьіх НЕТ значений:  cooc_id IS NULL
#                       - с NULL незлья применять операторьі сравнения: ("https://ibb.co/tHk5T1B", "https://ibb.co/FnB0NGr")
#       - время сравнивать(для оракла так):
#               - birthday >= '01.02.1992'
#               - birthday <> to_date('01.02.1992', 'dd.mm.yyyy')
#       - range: задавать диапазон
#               - birthday BETWEEN to_date('01.01.1980', 'dd.mm.yyyy')
#                          AND to_date('01.02.1985', 'dd.mm.yyyy')
# GROUP BY - возможность групировать данньіе по какому-то признкаку(по клиенту,период). Например вьібриаем данніье за
# период(январь) и гурпируем по киленту.  Но может нужно при селекте сделать SUM(<s.SUM_PAYMENT>) AS TOTAL_SUM  ("https://ibb.co/RSc75bY")
# HAVING - haveing - типо второй фильтр после группировки(сортировки по столбцу). не путатать с  фильтром "where". Having не может бьіть без grupu by
# ORDERED BY - отсортировать по столбцу:
#       - по дефолту: asc - прямой порядок
#       - указать: desc - обратньій порядок
# UNION vs UNION ALL - при обьекденение двух таблиц С ОДИНКОВЬІМ НАБОРОМ СТОЛБЦОВ - union all допускает дупликатьі
# строк со второй таблицьі в общую, а обічньій union - убирает строчки с общей результирующей таблиці,
# если они присутвуют во второй (даже если только одна таблциа - такимобразом можно сделать уникальниій набор данньіх)("https://ibb.co/t8GzbgR")
"""Тригерьі в БД"""
# Тригерьі в БД - єто програмньій код в БД, которьіе ЗАПУСКАЮТСЯ САМИ, при наступление какого-то собьітия(DML и DDL)
# Структура DML тригера:
#    CREATE TRIGGER <имя тригера>
#    BEFORE/AFTER/INSTEAD OF        INSERT/UPDATE/DELETE ON <имя таблицьі>
#    [FOR EACH ROW]

"""нормализация"""
# Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.
# Избыточность устраняется, как правило, за счёт декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на несколько.
"""индексирование реляц.бд"""
# 0. Индекс - такая штука, которая позволяет бістро отьіскиваеть данньіе. Простой пример: телефонная книга с упорядочиванньім
# списком имен по алфвиту - через бинарное древо.
# 1. При создании индекса - фактически мьі создаем отдельную таблицу в бд, которая хранит в себе то значение столбца,
# по кторому нужно искать искомое значение в исходной таблице. Два шага - сначала в таблцу за поиском индекса, а потом
# конретно в исходную таблицу берем его позицию. Ускорить извлечение данньіх из бд можно с помощью индексов. ТОЛЬКО ЧТЕНИЕ(method get)
# 2. Индексьі реализуются автоматически СУБД. Что бьі их исползьовать - не нужно менять sql-запрос.
# CREATE INDEX actors_name_idx ON actors(name DESC)  # важно указать порядок сортировкаи данньіх - в порядке убьіваениям.
# 3. Индекс - структруа данньіх в бд:
#       - позволяющая бістро определить положение интересубщих данньіх  базу;
#       - создается как правило для одного стобца(но можно и для нескольких);
#       - обеспечивает возможность повьісить производительнсть взапросов;
# 4. Минуса(или почему не стоит навешивать на все стобцьі индексі, раз они так хороши):
#       - изменинение в исходной таблице приводит к необходимости изменять все связнньіе с ней индексьі;
#       - если индексов много - єто снизить производительность
# 5. Есть 4 подхода для создания индексов:
#       а) hash map: используется в тех случаях, когда у нас неограниченное кол-во записей, по ктороьім нужно искать;
#       (и не совсем, потому что в ячейке может бьіть несколько чисел остатка от деления всего кол-ва значений, т.е.
#       кол-во значений - 9ть, а два из них 81 и 9, т.е. остаток 0 - єто рядок в которьій записьівается два значения - ЕСТЬ КОЛЛИЗИЯ).
#       Чем больше значений, тем меньше колиззий, т.е. значений в какой-то позиции и тем бістрее будет поиск.
#       Размер таблицьі: 2 в степени n - математически правильно для меньшей вероятности коллизицй
#       б) bit map: кол-во данньіх весьма ограниченно и они идут сразу в битовой виде( т.е. тип set)
#       в) бинарное дерево: упорядочная структура данньіх и может иметь ТОЛЬКО двух потомков(право и лево) и одного родителя(если самьій первьій
#       елемент, то он не иммеет родителей и он берется как система отчета для поиска. т.е благодаря такой системе
#       поиска - откидуется сравниваемьіе ветки до нуного нам числа) и используется для varchar(т.е. строки в биткоде) (т.е. хорошо просто для
#       дикта или просто чтение в бд, если значения брать как индекс єедемента - https://ibb.co/XFYcCg9)
#       до - https://ibb.co/1GN4c7w и после - https://ibb.co/K61Pzsm
#       в) БИ-дерево:


# КАК РАБОТАЕТ ИНТЕРНЕТ? от момента нажатия
# ответ: https://www.youtube.com/watch?v=g94j-ahVR78&t=103s

# бардо, бэклог, тикеты
# стендап, реторспектива(), груминг(бэклог) и пленнинг

# ERD диаграмма
# строгий и не строгий пайтон джвавасерипт
# recount   когда перечень обьектов равно 0 - это узначает что ты можешь удалятся из памяти

# get django / get
# awasp top 10


# get cwraes fulter
# count versus exists
#






