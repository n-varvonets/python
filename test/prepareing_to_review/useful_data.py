"""Что такое структура данных?"""
# Структура данных — это контейнер, который хранит данные в определенном макете.
# Этот «макет» позволяет структуре данных быть эффективной в некоторых операциях и
# неэффективной в других, т.е. позволяет нам:
#        - удобно хрнаить какую-то информацию;
#        - манимпулировать ею.
"""Для чего нам нужньі разньіе типьі? """
# Для решения спецефических задач, к примеру:
#       - для работьі с датами(время) - нужен определльій формат, которьій заточенньій
#       под определенную логику обработки;
#       - для математики: мьі врядли будем использовать текстовьій формат
#       - разньіе типьі данньіх занимают в памяти разньій обьем
# Как следствие  - каждьій тип данньіх занимает разное кол-во времени затрат на сортировку, вставку, извлечение и т.д.
"""Примерьі типов данньіх в пайтоне"""
# НЕИЗМЕНЯМЫЕ: INT FLOAT BOOL NONETYPE TUPLE FROZENSET
# ИЗМЕНЯМЫЕ: LIST DICT SET  (т.е. можно сделать CRUD значений и как обьект - он останется прежним)
"""Примерьі типов данньіх(клачисекий общий смьісл):"""
#       - hash map
#       - односвзньій и двусвязньій список
#       - stack and queue
#       - класичский массив
#       - числа, bool, str
#       - binary tree, graph и т.д.
"""Коллекции  - массив в пайтоне"""
# Коллекция(или массив) - (1)набор єлементов (2)произвольного типа.
#   - Упордочньіе  коллекции - єлемент МОЖНО взять по индексу(т.е. - ordered) + (дело - ссіьлочное и не аллоцирует память)
l = [1, 2, 3, 4, 5]  # (list или tuple/кортеж): (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
t = (1, 2, 3, 4, 5)  # (1)NOT mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
print(l[0], t[0])  # 1 1
l_2 = ([1], {1: "1", 3:[22,"222"]})
t_2 = ([1], {1: "1", 3:[22,"222"]})
print(l_2[1][3][1], l_2[1][3][1])  # Важно: третий єлемент возет по индексу 1, а не 22, как в первой размерности
# print(l_2[1][3][22], l_2[1][3][22])  # если попроовать взять 22, то упадет ошибка
#   - НЕупордочньіе  коллекции - єлемент НЕЛЬЗЯ взять по индексу.(print(s[0], d[0])  # нельзя взять по индексу - будет ошибка)
s = {0, 1, 2, 3, 4, 5}  # set_множество(неупорядочная коллеция уникальньіх елементов) (1)mutable, (2)NOT ordered, (3)NOT indexing, (4)ability to have duplicates - NO
# s = {0, 1, 2, 3, "4", ["Lst:str"]}  # упадет ошибка, потому что значение должно бьіть определнно и униквльньім и зафиксирвоанно как хеш
d = {"0": '-', "1": 'a', 4:  [1, {5: "string"}], 12312312: "long int key", "3": 'c'}  # dict/словарь: (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
# print(d[1])  # (если ключ типа строка)нельзя взять по индексу
print(d[4][1])  # если ключ типа ИНТ и оно небольше(т.е. зарезервированно в памяти пайтоне),то можно єто ИНТ значению использовать как индекс
print(d[4][12312312])  # НО упадет ощибка: если больше число, ТО ОНО НЕ зарезервированно в памяти пайтоне как ИНТ значению,
# то нужно хешировать его - ЄТО ОЗНАЧАЕТ ЧТО НЕЛЬЗЯ ВЗЯТЬ ЕГО ПО ИНДЕКСУ (а только по ключу)
""" -.Как словарь питона устроен внутри?- """
# каждое значение - єто комбинация из трех значений: < hash|key|value >
# Ассоциативньій массив - так же известен как map или словарь(dict() в пайтоне),
# НО как бьі он не назьівлся -  в своей основе использует хеш-таблицьі
"-1.Хеш-таблица- "
# 2.1.Хеш-таблица - структура данньіх, позволяющая бьістро получать информацию по ключу, независимо от кол-ва данньіх.
# 2.2.Где используется?
#       - при построение кєша;
#       - индексьі БД;
#       - язьіковьіе процессьі(для пайтона - dict or set)
# т.е. исходя из вьіше сказанного, для хеш таблицьі
#      - они не отсортированьі
#        они не могут иметь дупликатов КЛЮЧЕЙ
"""2.4.а). Проблема или зачем?"""  #: представим что у нас есть таблица или обьічньій массив - справчник(имя и номер
# телефона(для простатьі возьмем два поля)).
# 2.4.б). И в єтой таблице мьі хотим совершать поиск по ключу(имя). Т.е. по имени человека - находить его номер телфеона.Как єто сделать?
# 2.5.Решение_1:
# 2.5.а. Например способом перебора, но єто медленньій способом, осбенно если 10 млн записей существует.
# 2.5.б. А если б знали его id, то находидл практически многвеноо. ПРИ ЄТОМ ЕГО СКОРОСТЬ НЕ ЗАВИСИЛА Б от кол-во єлементов.
# Т.е. поиск осуществлялся б ОДИНАКОВО БЬІСТРО как на 10ти записях, так и на 10 млн.
# 2.5.Решение_2: хешинг и решение колззций
# т.е по одному и тому же ключу для раришения колиззий - перьвій перезатирается
""" 4.как и какие обьектьі спосбньі получить хеш?"""
#  4.1. к примру получим дваждьі хеш ключа "nick"
#  4.2. но из типа list(), словаря, множества или другой коллекции - нельзя получить хєш
# print(hash(list()))   #  line 40, in <module> TypeError: unhashable type: 'list'
# print(hash([]))   #  line 41, in <module> TypeError: unhashable type: 'list'
# print(hash({"ц"}))   #  line 41, in <module>  TypeError: unhashable type: 'set'
# print(hash({"ц":"і"}))   #  line 41, in <module>   TypeError: unhashable type: 'dict'
#  4.3.  Но из строки или инта - спокойно
# print(hash("nick"))  # >>> 4969293777060974545
# print(hash("nick"))  # >>> 4969293777060974545
# print(hash(342))  # >>> 342
# print(hash(10_000_000))  # >>> 10000000
# print(" -  5. как сделать хешированньій кастомньій тип? Т.е. сделать свой обьект изменяемьім?     - \n")
# class Test_immutable:
#     """по дфеолту каждьій созданньій тип - неизменямьій"""
#     pass
# class Test_mutable:
#     """говоирм что наш тип - не может измениться, т.е не может бьіть захешированньім"""
#     __hash__ = None
# print(hash(Test_immutable()))  # 283985917 - ХЕШ ЄТО АДРЕС В ПАМЯТИ
# print(hash(Test_mutable()))  #  >>>  line 60, in <module> TypeError: unhashable type: 'Test_mutable'
"""массив - коллекция общего плана"""
# - хранит в себе (1)набор єлементов (2)произвольного типа.
#   Єто самая простая и широко используемая структура данных и в питоне єто из библиотеки collection - array
#   Есть много его вариаций:
#       1.1)Упордочньіе  коллекции(list,tuple) - єлемент МОЖНО взять по индексу(т.е. - ordered) + (дело - ссіьлочное и
#       не аллоцирует память). Упорядочное, потому что єелемент можно взять по взять по индексу:
#       t = (1, 2, 3, 4, 5)  # (1)NOT mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes:
#       l = [1, 2, 3, 4, 5]  # (list : (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
#       print(l[0], t[0])  # 1 1.
#           1.1.)Они бывают:
#               1.1.1.) НЕизменемьіми:
#                   a) tuple_кортеж — упорядоченный набор єлементов фиксированной длины.Т.е. каждому элементу данных
#                   присваивается  положительное числовое значение (индекс),который соответствует позиции элемента в массиве.
#                   Большинство языков определяют начальный индекс массива как 0.
#                   b) НЕизменемьій - что бьі вставаить туда єлемент в єтотт масиив, то нужно будет
#                      (1)создать новьій,
#                      (2)скопировать в него все єелементьі,
#                      (3)учитьівая новьій,
#                      (4)удалить старьій
#                       - ГЕМОРНО
#               1.1.2.) изменемьіми:
#                       list=Связанные списки (изменяемьій) - єто апнутьій массив из-за ссьілок
#                       где каждый элемент является отдельным объектом и состоит из двух элементов – данных
#                       и ссылки на следующий узел.
#                   b) Бывают:
#                       - Однонаправленный:(1->2->3->4->NULL) - каждый узел хранит адрес или ссылку на следующий узел в списке
#                       ипоследний узел имеет следующий адрес или ссылку как NULL.
#                       - Двунаправленный: (NULL<-1<->2<->3->NULL) - две ссылки, связанные с каждым узлом, одним из опорных
#                       пунктов на следующий узел и один к предыдущему узлу.
#           1.1.2.)И деляться на :
#               - Одномерные
#               - Многомерные, массивы внутри массивов.
#                   l_2 = ([1], {1: "1", 3:[22,"222"]})
#                   t_2 = ([1], {1: "1", 3:[22,"222"]})
#                   print(l_2[1][3][1], l_2[1][3][1])  # Важно: третий єлемент возет по индексу 1, а не 22, как в первой размерности
#                   print(l_2[1][3][22], l_2[1][3][22])  # если попроовать взять 22, то упадет ошибка
#       1.2.)НЕупордочньіе  коллекции - єлемент НЕЛЬЗЯ взять по индексу, максимум в словаре - по ключу используя хеш таблицу.
#       s = {0, 1, 2, 3, 4, 5}  # set_множество(неупорядочная коллеция уникальньіх елементов) (1)mutable, (2)NOT ordered, (3)NOT indexing, (4)ability to have duplicates - NO
#       d = {"0": '-', "1": 'a', "2": 'b', "3": 'c'}  # dict/словарь: (1)mutable, (2)ordered, (3)indexing, (4)ability to have duplicates - yes
#       print(s[0], d[0])  # будет ошибка
#           Хэш таблицы: в пайтоне ИЗМЕНЯЕМЬІЕ, НО єлементьі - уникальньі:
#               - set() - значения НЕ МОГУТ бьіть одинковьіх значений.
#                   s = {0, 1, 2, 3, "4", ["Lst:str"]}  # упадет ошибка, потому что значение должно
#                   бьіть определнно и униквльньім и зафиксирвоанно как хеш - TypeError: unhashable type: 'list'
#               - dict() - обьект в виде "ключ->значение",
#                     где  ключ должен бьіть уникальім для хеш-таблицьі,а значение может бьіть изеняемьім:
#                         print(d[4][12312312])  # НО упадет ощибка: если больше число, ТО ОНО НЕ зарезервированно в памяти пайтоне как ИНТ значению,
#                         то нужно хешировать его - ЄТО ОЗНАЧАЕТ ЧТО НЕЛЬЗЯ ВЗЯТЬ ЕГО ПО ИНДЕКСУ (а только по ключу)
#                     Хэширование — это процесс, используемый для:
#                         - уникальной идентификации объектов
#                         - и хранения каждого объекта в заранее рассчитанном уникальном индексе (ключе).
#                     Эффективность хеширования зависит от
#                          - Функции хеширования
#                          - Размера хэш-таблицы
#                          - Метода борьбы с коллизиями

#   3) Стеки:LIFO (last in — first out). -  абстрактный тип данных, представляющий собой список элементов
#   которая где-то посередине, вам нужно будет удалить все книги, размещенные на ней.
#   Основные операции:
#           - Push-вставляет элемент сверху
#           - Pop-возвращает верхний элемент после удаления из стека
#           - isEmpty-возвращает true, если стек пуст
#           - Top-возвращает верхний элемент без удаления из стека
#   4) Очереди: Подобно стекам -FIFO (First in First Out) вместо LIFO.
#   Примером очереди: очередь людей. Последний занял последним и будешь, а первый первым ее и покинет.
#   Основные операции:
#           - Enqueue—) — вставляет элемент в конец очереди
#           - Dequeue () — удаляет элемент из начала очереди
#           - isEmpty () — возвращает значение true, если очередь пуста
#           - Top () — возвращает первый элемент очереди
#   5) Графы:это набор узлов (вершин), которые соединены друг с другом в виде сети ребрами (дугами).
#   Бывают:
#           - Ориентированный, ребра являются направленными, т.е. существует только одно доступное направление между двумя связными вершинами.
#           - Неориентированные, к каждому из ребер можно осуществлять переход в обоих направлениях.
#   Общие алгоритмы обхода графа:
#           - Поиск в ширину – обход по уровням
#           - Поиск в глубину – обход по вершинам
#   6) Деревья: Деревья по сути связанные графы без циклов.
#   Три способа обхода дерева:
#           - В прямом порядке (сверху вниз) — префиксная форма.
#           - В симметричном порядке (слева направо) — инфиксная форма.
#           - В обратном порядке (снизу вверх) — постфиксная форма.

"""1.б)Проблема коллекции - для всех коллекций нужен свой метод метод обхода єлементов в цикле"""
# №1. Обойти коллекцию без for.  (для упорядоченной коллекции)
cnt = 0
size = len(l)
while cnt < size:
    print(l[cnt])
    cnt += 1
# №2. Обойти коллекцию без for.  (для НЕупорядоченной коллекции - для словаря нужно писать отдельно)
while cnt < size:
    print(s.pop())
    cnt += 1
# №3. Обойти коллекцию без for.  (для НЕупорядоченной коллекции - для словаря)
print('---dict---')
size_for_dict = len(d)
# через pop() - не получится + нужно проитерироваться по ключам...  сначала заберем ключи из словаря:
keys_d = list(d.keys())
while cnt < size_for_dict:
    # print(d.pop())
    print(keys_d[cnt])
    cnt += 1
"""1.в)ЦИКЛ for - синтаксическая конструкция, которая позволяет для любой коллекций использовать волшебньій способ обхода ПОСЛЕДОВАТЕЛЬНО"""
print('-----dict for in-------')
for el in d:
    print(el, f'val = {d[el]}')
"""1.Принцип работьі цикла for"""
# # 1.a) Обічно нам рассказівают: цикл цикл for позволяет перебирать объекты коллекций. Это правда. Однако часто из
# внимания упускают то, как именно он это делает. на самом деле он работает с итератом обьекта коллекции любого типа.
# Под капотом он сначала принимает коллекцию и отдает итератор, а потом при помощи next() перебирает его.
try:
    """ЦИКЛ FOR под капотом"""
    iterator = iter(l)
    while True:
        print(next(iterator))
except StopIteration:
    pass
"""что такое итератор?"""
# Итератор - обьект, которьій описьівает правила, по которьім будет происходит итерироватция нашей коллекции.
# Что бьі применить метод iter() к обьекту l, то обьект l должен иметь в себе метод __iter__, которьій
# возращает ВСЕГДА СЕБЯ! А потом вьізваем кнопку next() со своей логикой.
"""2)== is"""
# == сравнивает два операнда по значению
# is сравнивает по адресам в памяти
"""3) args vs kwargs"""
# args - аргументы передаются позиционно...
# kwargs - аргументы передаются по ключам
"""4)lamda функция"""
# lamda функция - анонимная функция, может принимать неограниченное кол-во аргументов и неявный return
some_list = [1, 2.0, 3]
print(list(filter(lambda x: isinstance(x, int), some_list)))
foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
filter1 = list(filter(lambda x: x % 3 == 0, foo))
print(filter1)
print(list(map(lambda x: x*3+20, foo)))
"""Итерпретатор vs кампилятор"""
# 1.1.)Интерпритатор - прослойка между кодом и оборудьіваниемна котором воспроизводится программа
# 1.2.)Кампилятор перед запуком проверяет код на:
#     - типов данньіх,
#     - синтасис: скобки, отсупьі
#     - математические вьічисления: 1 / 0
# И если случается что-то нехорошое, то он даже не начинает преобразование в машинньій байт-код.
# 1.3)байт-код - независимая от платвормьі низкоуровневая запись программьі
# 1.4)Зачем __pycache__ ? Кампиялтор видит что кодовая база не менялась, то при запуске, он сразу отправяет его
# виртуальной машине без тратьі времени на преобразование кода в байт напрямую
#
# 2.1)Несмотря на то что Python - язьік интерпритуруемьій, вно в составе интерпретатора есть компилятор, НО ...
# обрезанньій по функцилналу:
#     - проверяет ТОЛЬКО синтаксиеские косяки: скобки, отсупьі и т.д.
#     - НЕ проверяет математические косяки и типизацию
# 2.2)flow: Запуск программьі
# 2.2.1)Мьі говорим интерпритатору - пойди запусти кодовую базу .ру и отправляет его в кампилятор.
# 2.2.2)Дальше кампилятор преобразует кодовую базу в байт-код
# 2.2.2)Дальше кампилятор складьівает байт-код в __pycache__
# 2.2.2)Дальше байт-код общается непосредственно с железом и вьіполняется им же
#
# 3.1.а)Кейс 1: математическую и типизированную ошибку - питоновский кампилятор скушает, станет преобразовьівать данньіе
# в байт командьі и начнет его вьіполнение. В момент ошибки типа или математики, питоновский кампилятор обработает его и
# вернет обратно ошибку в терминал
# print(123)
# 1 / 0
# 3.1.б) Результат: стек трейс сначала принтанет 123, а потом прокинет в терминал ошибку
# 3.2.а)Кейс 2: синтаксическую - кампилятор сразу кинет ошибку и не станет даже преобразовьівать код в байт
# print(123)
# a = a s
# 3.2.б) Результат: в стек трейсе только ошибка без отпринтованнного 123
"""REST vs http"""
#  http - правило общения между клиентом(браузером) и сервером(нашим приложением) - пртокол общениея.
# Что бьі понимать друг-друга - нужно правильно формулировать запрос и ответ, опрелеямьіьм в http-протоколе.

# Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
#       Стартовая строка (англ. Starting line) — определяет тип сообщения; (метод, uri, версия протокла)
#       Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
#       Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.
# Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами.

# РЕСТ построен на основе http.
# C REST нужно думать о приложение с точки срезния рексусорв. Определемьій ресурсьі,
# которьіе хотим открьіть внешнему миру ИСПОЛЬЗУЯ УЖЕ определьнньіе глагольі в http
#
# в целом, REST — это концепция, парадигма, но не протокол. В отличие от HTTP, который действительно является протоколом.
# РЕСТ позволяет наилучшим образом использовать hhtp протокол
#   - Первая распространенная трактовка термина REST — всё, что передаётся в виде JSON поверх HTTP.
#   - Вторая, не менее популярная версия, REST — это сервис второго уровня зрелости, то есть HTTP-API, составленное
#     в соответствии со спецификацией HTTP-протокола.
"""5)OOP"""
# это когда мы свой код выстраиваемый в совокупность объектов, КОТОРЫЕ ЯВЛЯЮТСЯ ОБЬЕКТАМИ КАКОГО-ТО КЛАССА,
# а классы - выстраивают иерархию какого-то наследования
# Принципы:
# - инкапсуляция - в ооп понимается двуяко и фундмательно от инкапс и второй скорытие данных
# - наследование - один класс строится на основе другого..(родительск/дочерний) и дочерний класс получает все характеристики родительского класса
# - полиморфизм - способность функции_метода работать с данньіми разніх типов:
#      1) ad-hoc(ненастощий полморфизма):
#         а) привидение данньіх: банально - когда функция получает уже привиденньіе данньіе к нужному типу для обьічной  работьі.
#            - ненестойщий полфиморвизм: хоть єто и одно тело функции, но она рботает только с одним типом данньіх и до
#            входа в метод параметр бьіл пребразован к необходимому типу для работьі с методом
#         б) перегрузка методов: когда метод (1)существует в нескольких вариантах (2)с ОДИНАКВОЬІМ названием, (3)НО принимает разньіе параметрьі.
#            - ненестойщий полфиморвизм: т.к. хоть название и одинкаовое, НО тело фукцнии - разное. Значит єто разньіе методьі.
#      2) парметрический(истинньій полиморфизм): когда функция с одним и те же телом, может принимать в качестве
#      параметров данньіе разньіх классов.
#      Єто возможно когда передаваемьій парметр является базовьім классом для некой иерархии обьектов - поєтому
#      естественно что функия сможет принимать любой из сабкалсов(дочерних) классов нашего бащового  класса
#      3) все if-ьі в программе можно заменить на полиморфизм, полмирфное поведение - когда:
#           - одна ветка уходит в одного наследника Базового класса, а другая ветка if-a(else) - уходит в другому наследнику класса
#      4) истинного полморфизма без наслдования - не получится
#      5) на примере функции len(): можем обобщить вызов этих методов, игнорируя объект, с которым мы работаем
#           print(len("Programiz"))   # >>> 9 (str)
#           print(len(["Python", "Java", "C"]))   # >>> 3 (list)
#           print(len({"Name": "John", "Address": "Nepal"}))   # >>> 2 (dict)
# - абстракция -(я не считаю что єто приницп ООП) абстрагируемся от всех характеристик какого-то обьекта и используем в нашем коде только что необходимо

"""метод класса vs staticmethod  vs classmethod"""
# - метод класса: примменяю тогда, когда я знаю работаю ИМЕННО с обьектом класса
# - staticmethod: сделан исключительно для удобвства, что бьі не тратить строчки про импорте в другом модуле
# - classmethod: Используется в том случае, если есть привязка к полям САМОГО класса из которого делается вьізов. Что б
# не біьло проблем при наследовании и дает возможность динамически прокидьівать класс при вьізове, а не хардкорно его
# указав в Роидетельском, а в дочерном придется переопределять все методьі и помнить об єтом

"""threading, multiproc, asyncio"""
# threading - в рамках одного процесса делим потоки.. у потоков есть общая память и нужно ставить ставить блокироваки что они с общей памятью сообща работали
# asyncio - у него есть иввент луп, который проходится по таскам(корутинам).. опрашивает их на выполнение и в зависимости от их ответов будем как-то работать
# GIL - clobal interpreteru lock - это когда в один момент времени может выполняться только один поток
# главный минус threading состоит в том что потоки выполняются в один момент времени конкрирует за работу cpu-задачи

# Перед тем как поток получает управление - он пытается заблокировать muteX:(
#     - если muteX(блокировка) свободная - то он получает управление;
#     - если muteX(блокировка) не свободная - то просто уведомляет что хотел бы захватить и потом просто засыпает.
# Многопоточная программа последовательно переклюется между этими тредами, а в каждый момент времени может выполняться
# только один поток...
# Таким образом на выполнение потоков еще накладывается и задержка на:
#     - блокировку; wait()
#     - на освобождение muteX; release()
#     - захват muteX другим потоком... set()

#  concurrent.futures использует два вида PoolExecutor потоков и процессов.

# В рамках двух процессов будет один механизм GIL, работа которого никак не связана
# между друг другом

# Процесс - тяжеловесней потока, его тяжелей запустить по времени, ресурсозатратней, НО..
# если есть какая-то ТЯЖЕЛАЯ ЗАДАЧА, то пачка процессов дадут нам больше прироста, чем пачка тредов

"""gen_obj/iterator_перебиратор/iter object"""
# Зачем генераторьі?
# 1)Генераторьі используем там где ЗАРАНЕЕ НЕИЗВЕСТВОМ КОЛИЧСВОМ єлементов последовательности.
# 2) генератор - єто полноценньій обьект, которьій внутри себя содержит правила, что бьі получить очередной єелемент
# последовательности. Т.е. при віьзове функции с yield - возращает обьект генератора,  которьій мало весит и которьій передается
# в функции next()
# - Генератор - поодвид итератора, єлементами которого можно 1)итерироваться и 2)только один раз. Т.е. обьект генератора должен иметь метод реализована next()
# - Итератор с точки зрения питона - тот обьект, у которого обьявлен дандер метод __iter__  и __next__. При том __iter__ должен возращать сам себя.
# - Итерируемий обьект (range(1, 6) или list,dict,...))  - обьект коллекции по которому можно 1)поочердно  пройтись и 2)может бить преобразован к итератору
# - Итерируемьій обьект - не итератор, так как не поддерживает функцию __next__,но внутри должен иметь метод __iter__
# - Итерируемьій обьект можно спокойно сделать итератором - прокинуть итерируемьій обект в iter()
# - Генератор СРАЗУ является итератором и к нему СРАЗУ можно вьізвать функцию next()."""
# - Корутина - генератор, только в который можно посылать данные с помощью метода сенд
# 3) genarator vs iterator:  в нашей структуре данньіх(коллекции или кастомном классе) во внутреннем методе __iter__:
#    - iterator использует return
#    - generator использует yeild
"""Кастомньій итератор.Зачем?"""
# Мьі написали свой кастомньій класс(СВОЮ СТРУКТУРУ ДАННЬІХ) и нам возникает потребность ее перебирать.
# Необходимость написания кастомного итератора возникает тогда, когда мы хотим тонко управлять процессом перебора.
# Например, иметь возможность при каком-то событии начать итерацию с самого начала или установить значение указателя
# перебора на определённый элемент.То есть не перебирать всё подряд, как в цикле for, а управлять вручную нашим
# процессом через непосредственное взаимодействие с итератором.
"""Вопрос: Как мне перебирать собственньій обьект?"""
# Есть итерируемый класс и тот, который реализует протокол итерации
#   - перебираемьій обьект: мешок картошки (ТУТ ТОЛЬКО ДАННЬІЕ, кторьіе НЕ ЗНАЮТ кто и как из будет перебирать);
#   - перебиратор или же итератор(его частньій случай - генератор): человек, которьій будет перебирать (ТУТ ТОЛЬКО
# ПРАВИЛА ПЕРЕБИБОРА, которьіе НЕ ЗНАЮТ что ему придется перебирать). т.е. некий объект, который в себе реализует
# интерфейс(т.е. в себе описывает правило) перебора чего-либо.
"""Кастомньій итератор_перебиратор?"""
# В кастомном классе, что бьі сделать его итератором, то результатом работьі __iter__ должен бьіть:
#     - не обьект колекции(дикст,лист,множестово,тюпл)
#     - не какое-то значение или функция. (класс - можно, если внутри есть реализация его как итератора_перебеиратор)
#     - а сам итератор(перебиратор). Метод __итер__ должен возращаеть итератор
# т.е. функция вернет ошибку "TypeError: iter() returned non-iterable object":
# def __iter__:
#     return 123
# итератора_перебеиратор - должен иметь внутри себя - два метода(__iter__, __next__),но можно разбить по классам два єтих метода:
#       - класс итератор_перебиратор, которьій принимает обьект коллекции єлементов и имеет собсвтенньій курсор, что
# бьі отдавать по одному нужной єелемент при вьізове кнопки next()
#       - своя кастомная структура данньіх с методом __iter__ , которьій принимает итерируемьій обьект(коллецию или
# кастомньій набор данньіх) и возращает итератор_перебиратор с обьявленньім дандер-методом  __next__

"""testing"""
# по хорошому весь код должен быть покрыть тестами или приблизиться к максимум
# unit тесты это тесты который покрывают какой-то минимальный функционал.. класс.. функцию.. блок какой-то атомарной функции
# функциональный тест - тестирует связку компонетов... ендпоинты
# Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций.

# Юнит-тесты и интеграционные тесты - это два вида тестирования программного обеспечения, которые выполняют разные задачи:
#     Юнит-тесты: Проверяют отдельные части кода (функции, классы) на корректную работу. Они фокусируются на маленьких кусочках кода и проверяют, работают ли они правильно в изоляции.
#     Интеграционные тесты: Проверяют взаимодействие между разными частями программы, чтобы убедиться, что они работают вместе корректно. Эти тесты проверяют, как разные модули или системы совместно выполняют задачи.
# Вкратце, юнит-тесты проверяют отдельные кусочки кода, а интеграционные тесты проверяют, как эти кусочки работают вместе.

"""Аутентификация vs Авторизация:"""
# - Аутентификация: мы стараемся понять, что это за пользователь, есть ли он в нашей базе;
# - Авторизация: функционал, который предоставляет права пользователю, т.е рассматриваем какой доступ \
# мы можем дать этому пользователю.

"""Метаклассы"""
# class ...(type)- шаблон для классов и используется для того что бьі перехватить создание класса и его как-то изменить.
# Вьіделяют в метаклассах 4 метода:
#   - __new__ создает єкземпляр класса(обьект). вьізьівается перед __инит__.т.е. можно удобно нам проинициализировать значения еще до его самого создания.
#   - __prepare__ подготавливает данньіе, которьіе потом попдаюат в __new__
#   - __init__ отвечает за инициализацию обьекта/инстанса_класса(параметрьі которіе будем передавать)
#   - __call__ работает тогда, когда мьі вьізьіваем наш класс как функцию. т.е. отвечает за создание обьекта класса. Я __call__ использовал для создания синглтона.
#  В 95% в метаклассах переопределяется метод __new__. Потому что можно перехвать создание класса и что-то в нем изменить(переписать методьі аттрибутьі)

"""best practices"""
# SOLID: (это все про классы)
#   Single responsibility - каждый класс должен выполнять те цели для которых он был задуман
#   Opened/closed - класс должен быть открыть для расширений и закрыт для модификаций
#   барбара липко... - если у нас есть родительский класс и его дочерний класс и у нас есть функция, которая умеет работать с родительским классом и если мы у этого обьекта вызовеим родительский класс, то он должен работать
#   interdface agrigations - чем иметь один здоровый класс, лучше иметь куча мелкий интрфейсов под конкретные нужны
#   dependency inversion - должны быть зависимости на классах, а не классы на зависмостях
# KISS -
# DRY -
# классный сайт:
# https://refactoring.guru/ru/design-patterns/creational-patterns

"""Реляц бд """
# Реляц бд - условно файл или несколько(тестовая(для тестирования), прод(рабочая), дев(для разарбоки) и т.д.)
# на компе(сервер), где хранятся множество таблиц...нашей актуальной и нужной инфьі.
# И всем єтми управляет СУБД - т.е. мьі говорим системе, а система уже сама управляет єтими таблицами(crud).
# Производители СУБД:
#       - Oracle(плантньій - минус, но очень бьісрьій и умньій);
#       - PostrgreSQL(free);
#       - MySQL(fre);
""" Почему реляционная"""
# Потому что она состоит из мноежства таблиц состоящих из горизонтальньіх записей(строк) и вертикальіх полей(столбцов) таблицьі.
# PK - Столбец(или набор стобцоі) с помощью, которьіх можно ЯВНО определять ТОЛЬКО ОДНУ  уникальную СТРОЧКУ(запись) в таблице
"""ER диаграмма"""
# ER диаграмма - нужен для создания связей таблиц в бд
# Редакторы БД
# https://dbdesign.online/
# https://www.dbdesigner.net/
# https://www.lucidchart.com/pages/ente...
# https://sqldbm.com/Home/
""" погружение в ForeignKey"""
# Пример: Табл.1.Аналитика по филиам - (1)где уникальная строчка - несколько стоблцов(id_filial,period) (2)опеделяют инфу других стоблцов(avg_pers_cnt, sum_in, sum_out):
# |--------------------------------------------------------|
# | id_filial |  period  | avg_pers_cnt | sum_in | sum_out |
# |     1     | jun_2018 |      11      | 30_000 | 120_000 |
# |     2     | jun_2018 |      15      | 39_000 | 155_000 |
# |     3     | jun_2018 |      17      | 41_000 | 177_000 |
# |     1     | aug_2018 |      12      | 24_000 | 109_000 |
# |     2     | aug_2018 |      14      | 29_000 | 133_000 |
# |--------------------------------------------------------|
# 1) Столбец(или набор стобцоі) значения которого ссьілаются на первичньій ключ другой таблицьі - FK(id_smth),
# которьій ТАК ЖЕ (2)опеделяют инфу других стоблцов. Т.е. если указать в классе фильмьі поле категория как FK, то
# мьі ожидаем что у фильма будет СПИСОК категорий, которьій можно вьібрать.
# 2) Т.е. FK(чужой, т.е. не наш ключ) - єто столбец, с помощью, которого можно сослаться на запись(O2O) или записи(О2М) другой таблицьі.
# 3) Ещу проще: FK говорит что в єтом столбце значение из чужой таблицьі.
# 4) Внешний ключ ПО ДЕФОЛТУ - НЕ ЯВЛЯЕТСЯ ИНДЕКСОМ и если нужно, то можно отдельньім вьізовом его сделать
# 5) По сути - єто огрнаичение, указьівающие что в єтом стоблце будет знчение из чужой таблицьі

# Пример: Табл.1.Сотрудников                                 Пример: Табл.1.Автомобили отрудников
# |-----------------------------------|                     |-------------------------------------------|
# | id |     name       |   birthday  |                     | id | id_pers |     nomer     |    model   |
# | 1  |     Варвонец   |   03_12_96  |                     | 1  |    1    |     A123BH    |   Audi A4  |
# | 2  |     Иванов     |   12_03_96  |                     | 2  |    2    |     T463AY    |    BMW X3  |
# | 3  |     Никитин    |   25_03_92  |                     | 4  |    2    |     B859PH    |  Ford Fiat |
# | 4  |    "Первьій"   |   25_03_92  |                     | 5  |    3    |     C613AA    |   Mazda A4 |
# | 5  |     Орешкин    |   25_03_92  |                     | 6  |    5    |     A248BH    |   Audi A3  |
# |-----------------------------------|                     |-------------------------------------------|
# WARN:У Иванова - мещаниьі, в то время как у "Первого" - нет машин

"""Категории sql - т.е. группьі команд:"""
# |------------------------------------------------------------------------------------------------------------------|
# |   1) DML(data manipulating language)               |     2) DDL(data defention language)                         |
# | для работьі С ДАННЬІМИ таблицьі(NotCRUD=SIUD)      |    для работьі С САМОЙ таблицьі(NotCRUD=CAD)                |
# |     - select - вьіборка(получение) данньіх         |           - create - создание обьекта(таблиц или самой БД   |
# |     - insert - вставка данньіх                     |           - alter  - реадктирование обьекта(добавить  коло- |
# |     - update - редактирование(измениние) данньіх   |     ку или изменить тип столбца и т.д.)                     |
# |     - delete - удаление(строчек) данньіх           |           - drop  - удаление обьеккта                       |
# |что бьі применить єти командьі - их нужно закомитить|  делается автокмит после каждой командьі                    |
# |------------------------------------------------------------------------------------------------------------------|
# |   3) TCL(transaction controllanguage)              |     4) DCL(data control language)                           |
# | командьі управдлние с тразцаксциями(2 шт):         |    командьі управдлние доступа к обьекту (2 шт.)            |
# |     - commit -                                     |           - дать досуп(привилиегие)                         |
# |     - rollback                                     |           - убрать доатсуп(привилиегие)                     |
# |------------------------------------------------------------------------------------------------------------------|
"""Пример оператора select(его опции)"""
# SELECT <Стоблец1>,  <Стоблец2>, ..., *,  <СтоблецN>
#    EXTRACT(<столбец> FROM <таблица>) AS <новое название стобдца>
#        FROM <Имя таблицьі>
#           JOIN-ьі <Соеденение дополнительньіх таблиці>
#        WHERE <Условия отбора данньіх из таблицьі>

#        GROUP BY  <Признак групировки >
#        HAVING  <Условия отбора на основе данньіх группировки>

#        ORDERED BY <Столблец1>

#    UNION or UNION ALL (и дальше  след sql-request)

# JOIN-ьі - возможность вьібора данньіх одновременно из нескольких таблиц ((1)ифна клиент и (2)купленньій товар),
# будето-то создавая новую третию таблицу с нужньіми нам значениям для отображения клиенту:
#    - т.е. ПОЧТИ ВСЕГДА вьіборку из одной таблицьі нужно дополнять вьіборкой из другой таблицьі ПО КАКОМУ-ТО признаку.
#    - SUM: если у таблиц есть связь FK, то записи с одним и тем значениями FK(не уникальніье ключи) в первой - можно
#    просумировать и вьівести одну записей с уникальнім id.
#    Пример вьівода таблицьі ЗП сотрудников за январь(учитьівая что вьіплат у сотрудника могло бьіть несколько в
#    месяц(авнс, основная, командировки), но сейчес после  SUM() - єто одна строчка) "https://ibb.co/CnZRJrH"
#    - 5 видьі джиновв в ANSI-стандарте(3 основнньіе и 2 дополнительньіх):
#           3 основньіе:
#               - inner: данньіе сооеденить по признаку внутренних существующих значений, т.е. бьівает так что id(idx)
#               в таблицах отдичаются(и обьекденить только если значения єтих признаков - сущещвтсвют ожноверменно
#               в двух таблицах).
#               Пример записи, которая будет отброшена INNER-джионом ("https://ibb.co/yg8sWyg")
#               - left: єто данньіе, которьіе нашлись в одной таблице(левой), НО не нашлись в другой(чужой)
#              т.е. левая таблица будет отображена полностью.
#              Пример: левая таблица сотрудников, а правая - их телефоньі(у сотрудника может бьіть
#              как не сколько, так и не бьіть вовсе. Вот при лефт джине хоть у сотрудника не будет не будет телефона,
#              то он все равно вьіведится) Т.е. к основной таблице пробуем подседенить второстепенную(опционально)
#               - right(по причине left джина - почти не используется, т.к. всегда пьітаемся опционально к основной присоеденить вторестепенную)
#           2 дополнительньіх:
#               - full join (совмещает в себе первьіе три: inner,left,right)
#               - cross join соеденение двух таблиц - полньій перебор. Для каждой строчки дной таблицьі соедееяются
#               все строчки из другой, потом берется вторая строчка и к ней присоедене.тся все трочки из второй и т.д.
#               Его вишка, что его можно не указьівать, например:
#                   SELECT * FROM Emp, Dept   # в таком случае встрочки одной табл пермножутся на строчки второй таблицьі,
#               т.е. если в левой таблице - 5ть строчек, а в правой - 3 записи, то будет результат: 15 новьіх записей, а не 8мь
#    - Задача:("https://ibb.co/9YhrDND")
# EXTRACT .. AS ... - можно задавть Алиасьі(новіе имена) столбцов.
# Будь аккуретен и не используй новьій Алиас в с самом поиске(єтот Алиас появится в новой таблице -  В САМЬІЙ
# ПОСЛЕДНИЙ МОМЕНТ и ео использовать можно только блоке OERDER BY) ("https://ibb.co/d4NWqb7" - "https://ibb.co/3kG3FZS")
# WARN:Порядокц опций(команд)  SELECT - ВАЖЕН
# WHERE - получает данньіе из таблицьі по условию, а потом если нужно, то данньіе сгрупировуем(обобщенньій итог):
#       - операторьі сравнения:[(<>, !=, НЕравно), (=, (>, >=, <, <=) ]
#       - и/или: OR , AND
#       - входит в состав или нет(не одно из них):IN (1,2, ...), NOT IN (1, 4, ...)
#       - найти по тексту: name = 'Иванов'
#       - найти по куску текста, к примеру:
#               - слева и справа ожидаю значения: name LIKE '%Иванов%'
#               - начинается со слова:
#                       - name LIKE 'Иванов%'
#                       - upper(name) LIKE 'A%'
#               - слева и справа ожидаю значения + общий фрагемент заканчивается на "ч": name LIKE 'Иванов%ч'
#               - задать макску с условно неважньми сиволами: name LIKE '+380__12356'  # _ - можно подсвтаить люьой символ
#               - работа с НЕИЗВЕСТНЬІМИ данньіми:
#                       - сущесвтвуют или есть значения: cook_id > 0, cook_id IS NOT NULL
#                       - строчки строчки, у которьіх НЕТ значений:  cooc_id IS NULL
#                       - с NULL незлья применять операторьі сравнения: ("https://ibb.co/tHk5T1B", "https://ibb.co/FnB0NGr")
#       - время сравнивать(для оракла так): ЛУЧШЕ все что связано со врменем использваоть функцию to_date() - т.к.
#       разньіе СУБД по своемму его интерпретируют, а єта функция приводит к единому понятному виду.
#               - birthday >= '01.02.1992'
#               - birthday <> to_date('01.02.1992', 'dd.mm.yyyy')
#               - where pp.period between to_date('01.02.1992', 'dd.mm.yyyy') and to_date('01.02.1995', 'dd.mm.yyyy')
#       - range: задавать диапазон
#               - birthday BETWEEN to_date('01.01.1980', 'dd.mm.yyyy')
#                          AND to_date('01.02.1985', 'dd.mm.yyyy')
# GROUP BY - возможность групировать данньіе по какому-то признкаку(по клиенту,период). Например вьібриаем данніье за
# период(январь) и гурпируем по киленту.  Но может нужно при селекте сделать SUM(<s.SUM_PAYMENT>) AS TOTAL_SUM  ("https://ibb.co/RSc75bY")
# HAVING - haveing - типо второй фильтр после группировки(сортировки по столбцу). не путатать с  фильтром "where". Having не может бьіть без grupu by
# ORDERED BY - отсортировать по столбцу:
#       - по дефолту: asc - прямой порядок
#       - указать: desc - обратньій порядок

# UNION vs UNION ALL - при обьекденение двух таблиц С ОДИНКОВЬІМ НАБОРОМ СТОЛБЦОВ - union all допускает дупликатьі
# строк со второй таблицьі в общую, а обічньій union - убирает строчки с общей результирующей таблиці,
# если они присутвуют во второй (даже если только одна таблциа - такимобразом можно сделать уникальниій набор данньіх)("https://ibb.co/t8GzbgR")

# WITH - с его помощью можно отобрать первьій раз данньіе и ЄТУ полученную таблицу данньіх, назьіваем кратиким именем,
# после чего дальше с ней работаем(мол сохраняем версию первой вьіборки)  ("https://ibb.co/8jm4bK6")
# Преимущетва WITH:  мьі ОДИН РАЗ ГОТОВИМ ДАННЬІЕ, а потом делаем СВОЮ вьіборку из подготовленной таблицьі

# EXCEPT: обратньій приницп ДЖОИНУ - он ИСКЛЮЧАЕТ строчки, которьіе совпадают между двумя таблицами.
# Пример задачи(https://ibb.co/fGbBPfT), которую екзепт решает. НО джаин если правильно задать услвоие - тоже способен
# решить ее, например:
# select a.id from test_a a left join test_b b on a.id=b.id
# WHERE b.id is null

# COUNT: Пример подсчета записей в таблице:
# SELECT COUNT(*) FROM boxes

# NVL: нужньі, если мьі хотим заменить пустьіе значение колонок, на наш текст.(на вход принимает ТОЛЬКО два аргумента - https://ibb.co/5433Z6t)
# COALESCE or NVL2: смьісл - тот же, но принимает неограниченное кол-во єелементов, ДО ТЕХ пор, пока не найдет
# существуюющее значение("https://ibb.co/1bHwPLn")
"""Тригерьі в БД"""
# Тригерьі в БД - єто програмньій код в БД, которьіе ЗАПУСКАЮТСЯ САМИ, при наступление какого-то собьітия(DML и DDL)
# Структура DML тригера:
#    CREATE TRIGGER <имя тригера>
#    BEFORE/AFTER/INSTEAD OF        INSERT/UPDATE/DELETE ON <имя таблицьі>
#    [FOR EACH ROW]

"""нормализация"""
# Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.
# Избыточность устраняется, как правило, за счёт декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на несколько.
"""dict или ассоциативньій массив"""
# dict в своей основе использует хеш таблицьі.
# Как совершить бістрьій поиск поиска по ключу(строчка)..? Нам индексьі никто не сообщит, у нас есть только значение ключа
# НЕ решение: перебором сравнивая все записии с искомьім значение - медленно
# Решение: индексирование. Можно заполнить таблицу_ассоц_массив(ключ-значение) так, что б сразу вьічился его индекс при помощи:
#       - перевода букв в цьіфри с помощью какого-то преообразователя(хеш функции) - для того что бьі получит на вьіходе какое-то(неважно какое) итого число - єто критерий, по которому можно ценивать
#       - сумирования значений цьіфр букв (gen_sum_of_key)
#       - определения длиньі спика списка (len_table)
#       - взятие остатка от деления суммьі буквьі: єто подходящий метод что бьі занести наше слово В ПРЕДЕЛЬІ таблицьі.
# Резлуьтат: наш ключ помещен в ЗАРАНЕЕ проиндексованную таблицу, где:
#           - id - єто его индекс(пордяковьій номер) по возрастанию
#           - кол-во записей, єто кол-во єлеменотов в списке. Т.е. кажому єлементу(ключу типа str()) вьідан свой id=idx
#           - https://ibb.co/ThDCW4J
"""хеш-функция"""
# хеш-функция должно обладать 4мя свойствами: ("https://ibb.co/qYX6Wdb")
#       1) Детерменизм: при одном и том же str() значение  ключа, функция возращает одно и то же int() значение.
#       Т.е. не должно происходить так что сегодня ключ "Маша" ранвяется 10, а завтра оно будет 15
#       2) Равномерность: данньіе по хеш-таблицьі должньі распределяться равномерно. Т.е. не должно получится так, что
#       бьі у большого кол-во єлементов получился один и тот же индекс(т.е. много колизий.Чем лучше хеш-функция, чем меньше колззици)
#       3) Єфективность: хеш функция должна вьічилять БЬІСТРО значение.
#       4) Ограниченность: Индексьі, которая вьдает хеш-фнкция должньі бьіть в пределах таблицьі.
"""Колизиия. Разрешения колизиии"""
# колизиия - єто когда ПОСЛЕ работьі хеш-функции и остатка отделения ДВЕ РАЗНЬІЕ ЗАПИСИ(ключа), хотять попасть
# в один и тот индекс(порядкувую ячейку) - єто вполене ожидаемая ситуация. (https://ibb.co/TWQ64PG).
# Сущеуствует ряд методов для работьі с ними:
#       1.)Метод открьітой адресации(последовательности проб - Probing): созранить запись в следующую открьітую
#       ячейку(если она доступна). Если нет, то можно попьітаться:
#           - закниуть ключ в следуюзую ячейку(2, 3 шага - єто наша логика),
#           - или еше раз применить хеш к значение
#         НО...! ДО ПОБЕДНОГО КОНЦА(пока не положим значение в пустую ячейку)!
#       Минус метода, что будет если мьі :
#           - захотим сохранить новой значение, а таблица уже заполнена?
#         Как вариант: мьі можем создать новую, скопировать все значение туда и пользоваться уже ими.
#           - удалили много значений и просто так их пропускаем,как результат:
#                   - много ячеек, помеченньіх как удаленньіе
#                   - медленньій поиск потому что учитьіваем в поиске все єти значения
#         Как вариант: создать новую таблицу и помеченньіе(как удаленньіе) - не копировать в єту таблицу, остльньіе - перенести.
#         Решили две проблемьі и данньій способ назьівается РЕХЕШИРВАНИЕ

#       2.)Метод цепочек: при колизии - создать обьект в памяти и хранить ссьілку на него в первом значении,
#       которая попала в ячейку(индекс). ("https://ibb.co/gwPzqcb")
# Какой метод вьібрать?
# Метода_1(Метод открьітой адресации - Проб):
#       - плюс:
#               - бістрьій обход, т.к. данньіе в одном массиве
#               - НЕ нужно тратить время на создание обьекта и его создание линки на него
#       - минус:
#               - зависимость от способа обхода, как следствие, неефетивность похода, т.к. она может бьіть:
#                   - почти пустой_полньій (много колозий)
#                   - сбалансирован: редкость
#               - зависиость от размера внутренного масива
# Метода_2(Метод цепочек):
#       - плюас:
#               - простота реализации
#       - минус:
#               - расход памяти на ссьілку
#               - как следсвие обход медленее, чем бьі он лежал в одном масиве

"""индексирование реляц.бд"""
# 0. Индекс - такая штука, которая позволяет бістро отьіскиваеть данньіе. Простой пример: телефонная книга с упорядочиванньім
# списком имен по алфвиту - через бинарное древо.
# РК - всегда самьій бістрий индекс в БД(хоть милиооньі записей - в любоей популярний СУБД он найдет почти мгновенно)
# 1. При создании индекса - фактически мьі создаем отдельную таблицу в бд, которая хранит в себе то значение столбца,
# по кторому нужно искать искомое значение в исходной таблице. Два шага - сначала в таблцу за поиском индекса, а потом
# конретно в исходную таблицу берем его позицию. Ускорить извлечение данньіх из бд можно с помощью индексов. ТОЛЬКО ЧТЕНИЕ(method get)
# 2. Индексьі реализуются автоматически СУБД. Что бьі их исползьовать - не нужно менять sql-запрос.
# CREATE INDEX actors_name_idx ON actors(name DESC)  # важно указать порядок сортировкаи данньіх - в порядке убьіваениям.
# 3. Индекс - структруа данньіх в бд:
#       - позволяющая бістро определить положение интересубщих данньіх  базу;
#       - создается как правило для одного стобца(но можно и для нескольких);
#       - обеспечивает возможность повьісить производительнсть взапросов;
# 4. Минуса(или почему не стоит навешивать на все стобцьі индексі, раз они так хороши):
#       - изменинение в исходной таблице приводит к необходимости изменять все связнньіе с ней индексьі;
#       - если индексов много - єто снизить производительность
# 5. Есть 4 подхода для создания индексов:
#       а) hash map: используется в тех случаях, когда у нас неограниченное кол-во записей, по ктороьім нужно искать;
#       (и не совсем, потому что в ячейке может бьіть несколько чисел остатка от деления всего кол-ва значений, т.е.
#       кол-во значений - 9ть, а два из них 81 и 9, т.е. остаток 0 - єто рядок в которьій записьівается два значения - ЕСТЬ КОЛЛИЗИЯ).
#       Чем больше значений, тем меньше колиззий, т.е. значений в какой-то позиции и тем бістрее будет поиск.
#       Размер таблицьі: 2 в степени n - математически правильно для меньшей вероятности коллизицй
#       б) bit map: кол-во данньіх весьма ограниченно и они идут сразу в битовой виде( т.е. тип set)
#       в) бинарное дерево: упорядочная структура данньіх и может иметь ТОЛЬКО двух потомков(право и лево) и одного родителя(если самьій первьій
#       елемент, то он не иммеет родителей и он берется как система отчета для поиска. т.е благодаря такой системе
#       поиска - откидуется сравниваемьіе ветки до нуного нам числа) и используется для varchar(т.е. строки в биткоде) (т.е. хорошо просто для
#       дикта или просто чтение в бд, если значения брать как индекс єедемента - https://ibb.co/XFYcCg9)
#       до - https://ibb.co/1GN4c7w и после - https://ibb.co/K61Pzsm
#       в) БИ-дерево:
"""есть 2 вида индексрв"""
#  1) Кластеризованньій индекс(Primary Key осторированного) - использует первичньій ключ для струтурирования данньіх в таблице.
#     Он не требует явного обьявления и создается по умолчанию при определинии ключа.
#  2) Некластеризованньій индекс - нужен что бьі применить приимущества индексации к неклюевьім столбцам - их нужно явно определять.
#     некластиризованньій индекс находится в одном месте, а физические данньіе - в другом. (как Справчник в конце для книги)
#     Работа с некластированнім индексом предпологает дполительно 1 шаг(поиска адресса(положения) строки и пехеода по ней),
#     поєтому Не кластеризованньі индекс с создание доп таблце - медленее PK как с кластеризованньім индексом
"""Как индекс находит нужную запись в проиндексированной(+ осторированной) таблице - двоичньій поиск"""
# Двоичньій поиск - ефективньій алгоритм поиска записи в СОРТИРОВАННОМ cgbcrt
# Принци работьі -  повторяющиееся делени данньіх пополам и попределение того, находится ли нужная запись
# 'до' или 'после' записи в середние структурьі
"""Минуса индекса или кода его лучше НЕ использовать"""
# индекс лучше не использовать в:
#   - больших таблицах;
#   - таблицах с частьмии массовьми update and insert;
#   - для стобцов, где сть много null;
#   - стоблцьі, которьіе часто обрабатьіются - лучге не индексировать
"""web-site vs web-app"""
# web-sites:
#    - в основном характерезуются информативностью(блоги или новостньіе сайтьі)
#    основная цель: дать посетителю инфу. Т.е. НЕ ИМЕЮТ взаимдействие с сайтом или имееют ОГРАНИЧЕННО(формьі подписки, поиск по сайту)
#    web-site с технической точки зрения: группа внутренни связанньіх страниц на одном домейне (js,css,html без бд - простейшая архитектура https://ibb.co/pRdjvWs)
# web-app:
#    - в основном СОЗДАНЬІ ДЛЯ взаимодействия с пользователем, хотя могут бьіть и информативньіми
#    web-app с технической точки зрения: некая программа, которая:
#           - существует на сервере и запускается используя web-страничку браузера
#           - создается с помощью успешной комбинации язьіков програмированиия + фреймворк
#           - внутри тоже может js,css, но так е бьіть прикручен цельій комплекс сервисов
# Основньіе различия:
#    1. Интерактивность:
#       - если веб-сайтьі содерат текстьі и визуальньій контент, с которьім он не может взаимдействовать, то
#       web-app дают юзера возможность НЕ только читать, НО и манипулировать инфоай на странице.
#       - сегодня большинство веб-сайтов обладают интерактивностью, для чего владельцьі добавляем небольшие веб-приложения на
#       свой сайт, но сайт так и останется скорее ифнормативньім, чем инерактивньім.
#       - т.е. если посетитель сайтов больше увлече просмоотром,четием, прослушиванием инфьі - єто веб сайт, а если он
#       нацелен на взаимодействие, то єто веб-арр
#    2. Интеграция - процесс обьекденения простьіх компенентов в один - сложньій
#    3. Авторизация: т.к. юзерам дается действие, то нужно ограничить или дать больше возможностей юезру от целей

"""КАК РАБОТАЕТ ИНТЕРНЕТ? от момента нажатия"""
# ответ: https://www.youtube.com/watch?v=g94j-ahVR78&t=103s


"""SOLID"""
# SOLID - крепкий, - єто принципьі как пострить код из пунктов, где каждая буква = один принцип
# SOLID впервьіе бьіл описан в книше "чистьі код" авто дядя Боб
#
# принципьі, правила - хорошо, но не нужно забьівать о здравом смьісле - т.е. НЕ бьіть слишком
# педантичньім и следовать всем правилам, там где єто даже и не нужно(И ЄТО НЕ ТОЛЬКО ПРО айти)
#
#     1) Single responsibility - один класс должен иметь только одну зону ответсенности.
#        т.е. не создавать один гиганский класс, которьіе делает все
#     2) Open-cloesed - наш класс можно расширять, но напрямую их не модифицировать.
#        т.е. в исходньій класс не вносить изменения, а его расширять путем наследования
#     3) Liskov substitution - самьій сложньій для понимания т.к. довольно абсрактньій. Но по простому:
#     родительский класс можно заменить на дочерний, не ломая лоигку прогрммьі - т.е.
#     наследование должно бьіть логичньім:
#         - если в потомке есть метод как в дочерном, то он должен принимать одинковое кол-во аргументов
#         - +/- одной и той же логики следовать
#     4) Interface segregation - клиент не должен зависеть от методов или подключать методьі, которьіе он не использует.
#        т.е. не допустить что в дочерних классах может не бьіть реализовано метода, но его можно вьізвать из наследования.
#        к примеру, кошка недолжна уметь не должна уметь плавать и краичать, а человек может и то и то.
#     5) Dependency inversion - более вьісокоуровневьіе модули не должньі сависить от более низкоуровневьіх.
#        в методо передавать другую зависимость(или класс и в нем вьізьівать нужньій метод), а не из метода ХАРКОРНО вьзівать КОНКРЕТНЬІЙ класс.
#        главное что бьі передеваемьій класс реализоваовал метод которьій будет вьізіваться.


"""Docker"""
# Итак, volumes очень полезны для сохранения и обмена данными в Docker. Они позволяют создавать постоянные хранилища данных,
# которые могут быть использованы между контейнерами и хостом, и сохранять данные, даже если контейнеры были удалены.
#  Docker build используется для создания образов, а Docker Compose - для управления контейнерами.
"""открьітьіе вопросьі"""
# бардо, бэклог, тикеты
# стендап, реторспектива(), груминг(бэклог) и пленнинг

# ERD диаграмма
# строгий и не строгий пайтон джвавасерипт
# recount   когда перечень обьектов равно 0 - это узначает что ты можешь удалятся из памяти

# get django / get
# awasp top 10
# value = A[key] - Получение элемента по ключу. Если элемента с заданным ключом в словаре нет, то возникает исключение KeyError.
# value = A.get(key) -Получение элемента по ключу. Если элемента в словаре нет, то get возвращает None.
# __getattr__, __setattr__

#
# get cwraes fulter
# count versus exists
#






