"""1) Типы данных"""
# НЕИЗМЕНЯМЫЕ: INT FLOAT BOOL NONETYPE TUPLE FROZENSET
# ИЗМЕНЯМЫЕ: LIST DICT SET
"""2)== is"""
# == сравнивает два операнда по значению
# is сравнивает по адресам в памяти
"""3) args vs kwargs"""
# args - аргументы передаются позиционно...
# kwargs - аргументы передаются по ключам
# т.е. аргументы передаются по значениям(НЕИЗМЕНЯМЫЕ) или по ссылкам(ИЗМЕНЯМЫЕ)


def some_function(some_arg: list):
    some_arg.append(1)
    return some_arg


print(some_function([]))
print(some_function([]))

list_ex = []
print(some_function(list_ex))
print(some_function(list_ex))
print(some_function(list_ex))

"""4)lamda функция"""
# lamda функция - анонимная функция, может принимать неограниченное кол-во аргументов и неявный return
some_list = [1, 2.0, 3]
print(list(filter(lambda x: isinstance(x, int), some_list)))

foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]

filter1 = list(filter(lambda x: x % 3 == 0, foo))
print(filter1)

print(list(map(lambda x: x*3+20, foo)))

"""5)OOP"""
# это когда мы свой код выстраиваемый в совокупность объектов, КОТОРЫЕ ЯВЛЯЮТСЯ ОБЬЕКТАМИ КАКОГО-ТО КЛАССА,
# а классы - выстраивают иерархию какого-то наследования
# Принципы:
# абстракция - абстрагируемся от всех характеристик какого-то обьекта и используем в нашем коде только что необходимо
# инкапсуляция - в ооп понимается двуяко и фундмательно от инкапс и второй скорытие данных
# наследование - один класс строится на основе другого..(родительск/дочерний) и дочерний класс получает все характеристики родительского класса
# полиморфизм - (парметрический)в функциях нам ве равно на типы данных которые прилитаеют извне.. главное что бы внутри функции в этом аргументе был реализован весь вфункционал с которым мы работаем

"""генератор"""
# генератор - такая цикл который вместо реткрна использует  yeald(такая вещь которая умеет принимать и отдавать контроль управления)
# отработанный генератор хранить значений в обьекте и методом next отдает след значение
"""корутина - генератор, только в который можно посылать данные с помощью метода сенд """

"""threading, multiproc, asyncio"""
# threading - в рамках одного процесса делим потками.. у потоков есть общая память и нужно ставить ставить блокироваки что они с общей памятью сообща работали
# asyncio - у него есть иввент луп, который проходится по таскам(корутинам).. опрашивает их на выполнение и в зависимости от их ответов будем как-то работать
# GIL - clobal interpreteru lock - это когда в один момент времени может выполняться только один поток
# главный минус threading состоит в том что потоки
# выполняются не в один момент времени, а они просто чередуются из-за GIL
"""
Перед тем как поток получает управление - он пытается заблокировать muteX:(
    - если muteX(блокировка) свободная - то он получает управление;
    - если muteX(блокировка) не свободная - то просто уведомляет что хотел бы захватить и потом просто засыпает.
Многопоточная программа последовательно переклюется между этими тредами, а в каждый момент времени может выполняться
только один поток...
Таким образом на выполнение потоков еще накладывается и задержка на:
    - блокировку; wait()
    - на освобождение muteX; release()
    - захват muteX другим потоком... set()
"""
"""
выше мы рассмотрели в модуле threading:
- как запускать
- как использовать виды блокировок (join(),set(),wait(),realise(),lock)
- как использовать потоко-безопасное хранилище
- GIL
"""
#  concurrent.futures использует два вида PoolExecutor потоков и процессов.
"""
В рамках двух процессов будет один механизм GIL, работа которого никак не связана
между друг друг, т.е. условно можно представить что два.  В отличи от четкого
последовательного выполнения потоков в процессе.

Процесс - тяжеловесней потока, его тяжелей запустить по времени, ресурсозатратней, НО..
если есть какая-то ТЯЖЕЛАЯ ЗАДАЧА, то пачка процессов дадут нам больше прироста, чем пачка тредов
"""

"""testing"""
# по хорошому весь код должен быть покрыть тестами или приблизиться к максимум
# unit тесты это тесты который покрывают какой-то минимальный функционал.. класс.. функцию.. блок какой-то атомарной функции
# функциональный тест - тестирует связку компонетов... ендпоинты
# Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций.

# Аутентификация vs Авторизация:
# - Аутентификация: мы стараемся понять, что это за пользователь, есть ли он в нашей базе;
# - Авторизация: функционал, который предоставляет права пользователю, т.е рассматриваем какой доступ \
# мы можем дать этому пользователю.

"""best practices"""
# SOLID: (это все про классы)
#   Single responsibility - каждый класс должен выполнять те цели для которых он был задуман
#   Opened/closed - класс должен быть открыть для расширений и закрыт для модификаций
#   барбара липко... - если у нас есть родительский класс и его дочерний класс и у нас есть функция, которая умеет работать с родительским классом и если мы у этого обьекта вызовеим родительский класс, то он должен работать
#   interdface agrigations - чем иметь один здоровый класс, лучше иметь куча мелкий интрфейсов под конкретные нужны
#   dependency inversion - должны быть зависимости на классах, а не классы на зависмостях
# KISS -
# DRY -
# классный сайт:
# https://refactoring.guru/ru/design-patterns/creational-patterns


"""нормализация"""
# Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.
# Избыточность устраняется, как правило, за счёт декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на несколько.

# КАК РАБОТАЕТ ИНТЕРНЕТ? от момента нажатия
# ответ: https://www.youtube.com/watch?v=g94j-ahVR78&t=103s

# бардо, бэклог, тикеты
# стендап, реторспектива(), груминг(бэклог) и пленнинг

# ERD диаграмма
# строгий и не строгий пайтон джвавасерипт
# recount   когда перечень обьектов равно 0 - это узначает что ты можешь удалятся из памяти

# get django / get
# awasp top 10

# Менеджер - интерфейс, через который создаются запросы к бд, который нужно в модели переименовать.Служат для того что бы \
# добавлять доп. методы в модель или же изменять базовые вытягиваняия из модели, т.е. изменять базовый queryset

# proxy не изменяет контент пользователя, он только изменяет её поведение, т.е. без создания новой таблицы в бд + можно менять менеджер

# Второй кастомный подход, когда нам необходимо прикреплять картинки/файлы к пользователям или другую доп.инфу.

# class Profile(models.Model):
#     user = models.OneToOneField(User, on_delete=models.CASCADE)  # связь О2О к модели пользователя, что бы создать новую таблицу \
    # с наими данными и ползователь должен быть один.. т.к. нельзя добавить новые поля в User, то просто раширяем его модель добавляя картинки

# Реализован сигнал post_save модели User, т.е. когда у нас создается новый пользователь, новый инстанс модели User вызывает \
# метод модели post_save и вызывается наша функция update_profile_signal
# @receiver(post_save, sender=User)
# def update_profile_signal(sender, instance, created, **kwargs):
#     """
#     Если флажок created создан, то в таком случае мы создаем для него Profile
#     sender - компонент, который посылает сигнал(новый пользователь модели User);
#     receiver - наша функция(update_profile_signal), которая обрабатывает сигнал(создает профиль с o2o)
#     """
#     if created:
#         Profile.objects.create(user=instance)
#         instance.profile.save()


# AbstractBaseUser и AbstractUser самые сложные типы кастомизации модели пользователя(в отличии от proxy или наследования User
# со связью O2O) и нужно продумать наперед перед миграциями. Если есть возможность - необходимо их обходить.

# AbstractBaseUser нуно использовать, когда надо изменить аутентификацию пользователей, или когда нам не подходит стандартный
# процес работы с пользователями. Например, у стандартно процес логина использует имя и пароль, а мы хотим мыло и пароль..
# AbstractBaseUser - совершенно новая модель.(миграции + setting.py)

# AbstractUser - сабклас AbstractBaseUser и его полная версия. Т.е. AbstractBaseUser -> AbstractUser -> Наша_кастомная_модель.
# Её используют, когда нас устраивает аутентификация в джанго, но необходимо добавить доп инфу в модель User, но по каким-то
# причинам мы не хотим создавать доп. класс как в случае с proxy


# темплейты - инструмент, позволяющий добавлять логику, а наш фронтенд не используя js. Темплейт состоит из 4х конструкций: \
# переменные(выводять значения из контекста {{ }}), теги(добавляют логику {% %}), фильтры(преобразуют переменные. фильтры могут
# быть как в тегах {% if element|Length >4 %} то так и в переменных {{ element|Length }}), комментарии{# for example #}.
# Пару примеров фильтров: |Length, |upper, |Linebreaks, |filesizeformat, |join:"_TEST" - больше смотри в документации
# ВАЖНО ПОНИМАТЬ: темплейты используются-выполняются только на этапе рендеринга страницы, если нам необходимо делать какую-то
# логику на уже готовой странице - тогда используется js. Темплейт подойдет для тех проектов, где нет необходимости очень
# сложного фронт-енда. Т.е. для большого проекта используется js.


# get cwraes fulter
# count versus exists
#
#
# sql:
#     dml and ddl
#     delete удаляет данныее из табл. дроп - удаляет тблицу как сущность

